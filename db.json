{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":1},{"_id":"themes/next/source/js/nav-toggle.js","path":"js/nav-toggle.js","modified":1},{"_id":"themes/next/source/js/motion_global.js","path":"js/motion_global.js","modified":1},{"_id":"themes/next/source/js/motion_fallback.js","path":"js/motion_fallback.js","modified":1},{"_id":"themes/next/source/js/lazyload.js","path":"js/lazyload.js","modified":1},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":1},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":1},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":1},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","path":"images/bkdefault_avatar.jpg","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/selection.json","path":"fonts/icon-linecons/selection.json","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","path":"fonts/icon-linecons/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","path":"fonts/icon-linecons/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","path":"fonts/icon-linecons/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","path":"fonts/icon-linecons/icomoon.eot","modified":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","path":"fonts/icon-icomoon/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","path":"fonts/icon-icomoon/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","path":"fonts/icon-icomoon/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","path":"fonts/icon-icomoon/icomoon.eot","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/selection.json","path":"fonts/icon-fifty-shades/selection.json","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","path":"fonts/icon-fifty-shades/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","path":"fonts/icon-fifty-shades/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","path":"fonts/icon-fifty-shades/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","path":"fonts/icon-fifty-shades/icomoon.eot","modified":1},{"_id":"themes/next/source/fonts/icon-feather/selection.json","path":"fonts/icon-feather/selection.json","modified":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","path":"fonts/icon-feather/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","path":"fonts/icon-feather/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","path":"fonts/icon-feather/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","path":"fonts/icon-feather/icomoon.eot","modified":1},{"_id":"themes/next/source/fonts/icon-default/selection.json","path":"fonts/icon-default/selection.json","modified":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","path":"fonts/icon-default/icomoon.woff","modified":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","path":"fonts/icon-default/icomoon.ttf","modified":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","path":"fonts/icon-default/icomoon.svg","modified":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","path":"fonts/icon-default/icomoon.eot","modified":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/CNAME","shasum":"fdebcf8f6827a8ea9cf1689042231fb685a49895","modified":1456663285000},{"_id":"source/_posts/DeducingType.md","shasum":"5e9e44a7626770158990399ecc7b706618dcd0e6","modified":1456663285000},{"_id":"source/_posts/cpp-rvo.md","shasum":"8cfa561e90c0f998534b9afcd499a9cde0e0ee7a","modified":1456663285000},{"_id":"source/_posts/hihocoder-binarygraph.md","shasum":"314748f314ed2d351a297d33bb18a9ea5c4f23f1","modified":1456663285000},{"_id":"source/_posts/hihocoder-kmp.md","shasum":"500174e9fe3caca6a4cb8f2d2fa32908936036ed","modified":1456663285000},{"_id":"source/_posts/hihocoder-trie.md","shasum":"92c6d0aa79ec7fcbf70f8601bffd95ff90623992","modified":1456663285000},{"_id":"source/_posts/hihocoder-trie2.md","shasum":"d64169f0f1e987f9715de007a272b7acaf68c581","modified":1456663285000},{"_id":"source/_posts/java-commonclass.md","shasum":"bae273822e726573a4bbb84ca8dac0b5636a63d5","modified":1456663285000},{"_id":"source/_posts/java-exception.md","shasum":"dbab700128872488956191ba00c3277adf5b039c","modified":1456663285000},{"_id":"source/_posts/java-fileio.md","shasum":"30863f5337e758c38db18c8af727d672bc5a9cd9","modified":1456663285000},{"_id":"source/_posts/java-hold-objects.md","shasum":"dc05bc56b92b65d67bd18256ef23f0c35109ee97","modified":1456663285000},{"_id":"source/_posts/java-polymorphism.md","shasum":"2c9ab5784d9b468c1f246e13b7492e6b5c0ea5b0","modified":1456663285000},{"_id":"source/_posts/java-string.md","shasum":"09d6bdb59827e45ddcef104bb6897012851f16a5","modified":1456663285000},{"_id":"source/_posts/modern-operating-systems-file-systems.md","shasum":"d7c722125b81781f6aa2a568a8fdf5aec49a526b","modified":1456764120000},{"_id":"source/_posts/singleton.md","shasum":"17f6d56d3cf73c13e4e766cf1e150d059c3ef8c3","modified":1456663285000},{"_id":"source/_posts/special-member-function.md","shasum":"9ca209ad3f3d859205d5d5201f5791d682f5a875","modified":1456663285000},{"_id":"source/_posts/tcp-closed-without-fin.md","shasum":"b44496bf0714ad17be5046f07896c62365659785","modified":1456663285000},{"_id":"source/_posts/universalreference.md","shasum":"dd51817cc0496c137eb792205cd1826290b3ced4","modified":1456663285000},{"_id":"source/about/index.md","shasum":"7148c8d5fc619ba243231138f7ec42af8d38488d","modified":1456663285000},{"_id":"source/categories/index.md","shasum":"66d4c4bc5d0b762e6fd0999b3b2f96a11df41e0a","modified":1456663285000},{"_id":"source/tags/index.md","shasum":"2c73270a246e25245940c529be56d2ea1620baf1","modified":1456663285000},{"_id":"themes/next/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1456665235000},{"_id":"themes/next/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1456665235000},{"_id":"themes/next/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1456665235000},{"_id":"themes/next/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1456665235000},{"_id":"themes/next/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1456665235000},{"_id":"themes/next/source/css/_variables/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1456665235000},{"_id":"themes/next/README.en.md","shasum":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1456665235000},{"_id":"themes/next/README.md","shasum":"3319de8565699fc9642f76c41ee96b50f2234b6a","modified":1456665235000},{"_id":"themes/next/_config.yml","shasum":"f215117d5a0573d1cbdb759499d279633f2567f6","modified":1456665235000},{"_id":"themes/next/bower.json","shasum":"1bdb0641bdcb9b5b154d2e379c57fe5675f06b9c","modified":1456665235000},{"_id":"themes/next/languages/de.yml","shasum":"7a8de0e5665c52a1bf168c1e7dd222c8a74fb0ab","modified":1456665235000},{"_id":"themes/next/languages/default.yml","shasum":"7e65ef918f16d0189055deb5f1616b9dedcb1920","modified":1456665235000},{"_id":"themes/next/languages/en.yml","shasum":"7e65ef918f16d0189055deb5f1616b9dedcb1920","modified":1456665235000},{"_id":"themes/next/languages/fr-FR.yml","shasum":"6d097445342a9fb5235afea35d65bf5271b772f0","modified":1456665235000},{"_id":"themes/next/languages/ru.yml","shasum":"b4a827b9ddac9d5f6dca096fe513aeafb46a3e93","modified":1456665235000},{"_id":"themes/next/languages/zh-Hans.yml","shasum":"8af76df5557561050a950bdd7091d3bb3939c5c0","modified":1456665235000},{"_id":"themes/next/languages/zh-hk.yml","shasum":"3fc38103c9efa6f6c37149adbddb014ff85ec849","modified":1456665235000},{"_id":"themes/next/languages/zh-tw.yml","shasum":"8897a06e521b36c7a1226c72057c8357611eded8","modified":1456665235000},{"_id":"themes/next/layout/_layout.swig","shasum":"54f049f8045d386587c1e5d9761c517553b79712","modified":1456665235000},{"_id":"themes/next/layout/_macro/post-collapse.swig","shasum":"42927bdde998cefd3cf4f19b0476d69bd9e5116a","modified":1456665235000},{"_id":"themes/next/layout/_macro/post.swig","shasum":"598b3085b6b74f4664eb66e6ae8737920e07d7a9","modified":1456665235000},{"_id":"themes/next/layout/_macro/sidebar.swig","shasum":"b0c467b42073270db7db41907ce8881f64bf3793","modified":1456665235000},{"_id":"themes/next/layout/_partials/footer.swig","shasum":"44d513401032362655c40cae66e579dba8dd3d85","modified":1456665235000},{"_id":"themes/next/layout/_partials/head.swig","shasum":"c96f50229b5d26687ec47f628cf3770b2cff8914","modified":1456665235000},{"_id":"themes/next/layout/_partials/header.swig","shasum":"eefb48589ed5b0894ac46883608618ac8a4dba3c","modified":1456665235000},{"_id":"themes/next/layout/_partials/old-browsers.swig","shasum":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1456665235000},{"_id":"themes/next/layout/_partials/pagination.swig","shasum":"d6c7f04eee4388d8f133eb5526b7c0875c321a30","modified":1456665235000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","shasum":"00c2b49f6289198b0b2b4e157e4ee783277f32a7","modified":1456665235000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","shasum":"2f92046e0b50ebd65abb7045b1cbbfc50abbb034","modified":1456665235000},{"_id":"themes/next/layout/_partials/search.swig","shasum":"64f14da26792a17bc27836c4e9d83190175f36e6","modified":1456665235000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","shasum":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1456665235000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","shasum":"63315fcf210799f894208c9f512737096df84962","modified":1456665235000},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","shasum":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1456665235000},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","shasum":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1456665235000},{"_id":"themes/next/layout/_scripts/analytics.swig","shasum":"0ebbf76c2317faa8ba31365adba59331c2e0262c","modified":1456665235000},{"_id":"themes/next/layout/_scripts/baidushare.swig","shasum":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1456665235000},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","shasum":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1456665235000},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","shasum":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1456665235000},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","shasum":"63b9648dcc03dc2536a7a887185fb15acfabceb4","modified":1456665235000},{"_id":"themes/next/layout/_scripts/fancy-box.swig","shasum":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1456665235000},{"_id":"themes/next/layout/_scripts/helpers.swig","shasum":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1456665235000},{"_id":"themes/next/layout/_scripts/mathjax.swig","shasum":"abc52fefb276c52cbb19de5c214521dfcf2a10fd","modified":1456665235000},{"_id":"themes/next/layout/_scripts/motion.swig","shasum":"817705bfd1a1282cb6bf59094afe507e11455aa0","modified":1456665235000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","shasum":"b63ef233886538f30ced60344ac15d25e5f3e0af","modified":1456665235000},{"_id":"themes/next/layout/archive.swig","shasum":"0c3ce594759f347ea90a4ce592a7a18e2ae4cc5c","modified":1456665235000},{"_id":"themes/next/layout/category.swig","shasum":"d6b3e1dc5e0b8deade9a084c463126e70188ee9b","modified":1456665235000},{"_id":"themes/next/layout/index.swig","shasum":"fdc801f0da71a2eb205ce9c0b12f156b219fdc9c","modified":1456665235000},{"_id":"themes/next/layout/page.swig","shasum":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1456665235000},{"_id":"themes/next/layout/post.swig","shasum":"a84457e8ced46e63bc7a8a9e0541a6ba53122a92","modified":1456665235000},{"_id":"themes/next/layout/tag.swig","shasum":"aab44af54fcbc66fea4ad12b2767ffca3eadd451","modified":1456665235000},{"_id":"themes/next/scripts/merge-configs.js","shasum":"dfd147d1317e56d283f5e779f00608e913603b51","modified":1456665235000},{"_id":"themes/next/scripts/tags/center-quote.js","shasum":"37274f743c2054244dcbbde56fba9ff353414281","modified":1456665235000},{"_id":"themes/next/scripts/tags/full-image.js","shasum":"0d69739d1bad5861a4a6ff2db511c3669783e438","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","shasum":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/buttons.styl","shasum":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/comments.styl","shasum":"54e73681ba6f57ef961138f94d2ee8ac845990c3","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","shasum":"c307f1e4827d7cb82816a5f9de109ae14ed4199c","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/gallery.styl","shasum":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","shasum":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/pagination.styl","shasum":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","shasum":"8f9e8f5f65956ccf1d52ff8526392803dff579d3","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","shasum":"4b82dbbb6e536e6e8ee3cec6e62c2fd4bea60a09","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","shasum":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1456665235000},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","shasum":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1456665235000},{"_id":"themes/next/source/css/_common/_core/base.styl","shasum":"e79a08484b191dca14ccfc005053eb95786dafae","modified":1456665235000},{"_id":"themes/next/source/css/_common/_core/helpers.styl","shasum":"41a31d651b60b4f458fc56a1d191dfbbdcb6d794","modified":1456665235000},{"_id":"themes/next/source/css/_common/_core/normalize.styl","shasum":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1456665235000},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","shasum":"cbd7f1d5c72e3024b5d70dafb6ca93e2723652ab","modified":1456665235000},{"_id":"themes/next/source/css/_common/_core/tables.styl","shasum":"f142a185fda68bc579e89ead9a31bc8fa0f3ca8c","modified":1456665235000},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","shasum":"8b809aef383bebaeb3f282b47675f3a364ce3569","modified":1456665235000},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","shasum":"80413afacfa656322100ce1900fed1ebcd8f8f44","modified":1456665235000},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"249f75bafa26b99d272352c0646e7497ea680b39","modified":1456665235000},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","shasum":"ec3f86739bede393cafcd3e31052c01115ae20d6","modified":1456665235000},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","shasum":"9cdbedb3627ac941cfb063b152abe5a75c3c699a","modified":1456665235000},{"_id":"themes/next/source/css/_common/_page/archive.styl","shasum":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1456665235000},{"_id":"themes/next/source/css/_common/_page/categories.styl","shasum":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1456665235000},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","shasum":"73796f6f13caa7151a2ee8e55755627e0d189f55","modified":1456665235000},{"_id":"themes/next/source/css/_common/_section/body.styl","shasum":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1456665235000},{"_id":"themes/next/source/css/_common/_section/footer.styl","shasum":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1456665235000},{"_id":"themes/next/source/css/_common/_section/header.styl","shasum":"ba501332fb111bd72dc0777f2e1c8a29ad538ff9","modified":1456665235000},{"_id":"themes/next/source/css/_common/_section/layout.styl","shasum":"4daaadd156ece64ae05908ad6bb0159c8a27c071","modified":1456665235000},{"_id":"themes/next/source/css/_common/_section/media.styl","shasum":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1456665235000},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","shasum":"d57e1769ebd2c472d2b27d17a706d3f564f94033","modified":1456665235000},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","shasum":"f3529b7da284c4b859429573c9b1004d32937e40","modified":1456665235000},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","shasum":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1456665235000},{"_id":"themes/next/source/css/_custom/custom.styl","shasum":"ed1360dfd016c40cce03421742362cabe3e581a0","modified":1456665235000},{"_id":"themes/next/source/css/_mixins/base.styl","shasum":"66985fe77bd323f7f8f634908e17166f51e96e95","modified":1456665235000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","shasum":"f3f4fac628d0b588cb40795d498110d33b11ce26","modified":1456665235000},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","shasum":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1456665235000},{"_id":"themes/next/source/css/_schemes/default/_search.styl","shasum":"c524bccdc554349106d1c8be9c3f275d4c0d4281","modified":1456665235000},{"_id":"themes/next/source/css/_schemes/default/index.styl","shasum":"2588e55132e10d82c0608f03c2c72a2bace8fa4e","modified":1456665235000},{"_id":"themes/next/source/css/_variables/Mist.styl","shasum":"f5dda1ca48c1b73a0bd34e08413de57699f24083","modified":1456665235000},{"_id":"themes/next/source/css/_variables/base.styl","shasum":"66e94d53e65a739c21111440b891d0d98068062b","modified":1456665235000},{"_id":"themes/next/source/css/main.styl","shasum":"b05c342e94ded24a5f2b203cedf77d3faa817fd5","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","shasum":"90763e97be18be78e65749075225cceeddc6fa8a","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","shasum":"f92ad8cddc250f0bb5ca466fca95d321987e127e","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","shasum":"c093408e6030221cafc1f79d897f1fb5283c1178","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","shasum":"dbe0368f2a65d87b13234cfea29d9783892fc7a8","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-default/selection.json","shasum":"dc07c29f687315f9458f6b251c214768af865fb2","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","shasum":"11554b9e9d5b9f535ba96cbb27d45d8c8f1689fd","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","shasum":"d5eb756eefda9b454dcb23c2b1cefd4051d18d41","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","shasum":"b2bbae4b613403cf61ad25037913378da1c07b8f","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","shasum":"2ea1c59c17422798e64ee6f4e9ce1f7aff1a06a5","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-feather/selection.json","shasum":"06ea91e3f98ebe1080087acad4356802bc5b6ebf","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","shasum":"da86ba5df72d1288de9e9633e5f528062dd427d5","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","shasum":"1a4afd739e1f8eb8d430dbdd29e36a9999802e8d","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","shasum":"72fe82e1f3db52414eed706952d385af241cb196","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","shasum":"4de6a74f523dee33d95dde61caae5809f9a5d448","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-fifty-shades/selection.json","shasum":"fdd09098d1c3688e2c88cf33fd51e76b383b6d7f","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","shasum":"301fcf00c24750dddf1c529f944ca62c7f1a217d","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","shasum":"e316347805eb93425faa678611c5e42a7152da8f","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","shasum":"f399713d1c9400d4d3373e38991a7e362a754a94","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","shasum":"05f1ec0bd307da5e731a86eb4961589a6042aebb","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","shasum":"e2d7f040428a632f3c50bfa94083b759936effc2","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","shasum":"808eaf7d61f7e67c76976265c885e79c36920f0b","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","shasum":"078068206684e4f185b0187ad3cee16f54a287d7","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","shasum":"0b07ee6ceda3b1bceb40c1e7379b3aa48dcc15a8","modified":1456665235000},{"_id":"themes/next/source/fonts/icon-linecons/selection.json","shasum":"db4ce25d31449ecc6685b32e145252103967bb5c","modified":1456665235000},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","shasum":"b687bb4bfbe35a32b592c24d652ba80cfdc770fc","modified":1456665235000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1456665235000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1456665235000},{"_id":"themes/next/source/images/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1456665235000},{"_id":"themes/next/source/images/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1456665235000},{"_id":"themes/next/source/images/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1456665235000},{"_id":"themes/next/source/images/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1456665235000},{"_id":"themes/next/source/images/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1456665235000},{"_id":"themes/next/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1456665235000},{"_id":"themes/next/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1456665235000},{"_id":"themes/next/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1456665235000},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1456665235000},{"_id":"themes/next/source/js/fancy-box.js","shasum":"c9782bfa8c1e51a8f8541530d836e75f48a433c2","modified":1456665235000},{"_id":"themes/next/source/js/helpers.js","shasum":"c2117b0ec653df4c45dd9d9575b190cbe1035335","modified":1456665235000},{"_id":"themes/next/source/js/hook-duoshuo.js","shasum":"ea30e91c6b7fdaa6dce4a848f25cdf90436b072a","modified":1456665235000},{"_id":"themes/next/source/js/lazyload.js","shasum":"b92e9acdc7afc15468314c03f4a643b0c93944cf","modified":1456665235000},{"_id":"themes/next/source/js/motion_fallback.js","shasum":"a767d522c65a8b2fbad49135c9332135c6785c3e","modified":1456665235000},{"_id":"themes/next/source/js/motion_global.js","shasum":"367e329b2cc19c6b7634ea2917a218c84a22ec17","modified":1456665235000},{"_id":"themes/next/source/js/nav-toggle.js","shasum":"78b59f1beb12adea0d7f9bcf4377cb699963f220","modified":1456665235000},{"_id":"themes/next/source/js/ua-parser.min.js","shasum":"acf0ee6a47ffb7231472b56e43996e3f947c258a","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1456665235000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"53360764b429c212f424399384417ccc233bb3be","modified":1456665235000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1456665235000},{"_id":"themes/next/source/vendors/fastclick/README.md","shasum":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1456665235000},{"_id":"themes/next/source/vendors/fastclick/bower.json","shasum":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1456665235000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1456665235000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1456665235000},{"_id":"themes/next/source/vendors/velocity/bower.json","shasum":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1456665235000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1456665235000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1456665235000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1456665235000},{"_id":"themes/next/test/helpers.js","shasum":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1456665235000},{"_id":"themes/next/test/intern.js","shasum":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1456665235000},{"_id":"themes/next/source/vendors/jquery/index.js","shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1456665235000},{"_id":"themes/next/source/vendors/velocity/velocity.js","shasum":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1456665235000},{"_id":"source/_posts/debug.log","shasum":"91a639fc9d13976a52cb76616c21d2207bac3bed","modified":1456663285000},{"_id":"public/vendors/velocity/velocity.ui.min.js","modified":1456764406716,"shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908"},{"_id":"public/vendors/velocity/velocity.ui.js","modified":1456764406723,"shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df"},{"_id":"public/vendors/velocity/velocity.min.js","modified":1456764406727,"shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6"},{"_id":"public/vendors/velocity/velocity.js","modified":1456764406730,"shasum":"9f08181baea0cc0e906703b7e5df9111b9ef3373"},{"_id":"public/vendors/velocity/bower.json","modified":1456764406741,"shasum":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409"},{"_id":"public/vendors/jquery/index.js","modified":1456764406744,"shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276"},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","modified":1456764406751,"shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18"},{"_id":"public/vendors/fastclick/lib/fastclick.js","modified":1456764406761,"shasum":"06cef196733a710e77ad7e386ced6963f092dc55"},{"_id":"public/vendors/fastclick/bower.json","modified":1456764406764,"shasum":"4dcecf83afddba148464d5339c93f6d0aa9f42e9"},{"_id":"public/vendors/fastclick/README.html","modified":1456764406772,"shasum":"4a6074903daa9004301ef30a6fb96556ba3eab60"},{"_id":"public/vendors/fastclick/LICENSE","modified":1456764406781,"shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","modified":1456764406795,"shasum":"53360764b429c212f424399384417ccc233bb3be"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","modified":1456764406799,"shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","modified":1456764406801,"shasum":"5f163444617b6cf267342f06ac166a237bb62df9"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1456764406803,"shasum":"53e194f4a72e649c04fb586dd57762b8c022800b"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1456764406805,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1456764406807,"shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1456764406810,"shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1456764406818,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1456764406827,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","modified":1456764406830,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","modified":1456764406832,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","modified":1456764406836,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","modified":1456764406838,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","modified":1456764406842,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/vendors/fancybox/source/blank.gif","modified":1456764406849,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/js/ua-parser.min.js","modified":1456764406857,"shasum":"acf0ee6a47ffb7231472b56e43996e3f947c258a"},{"_id":"public/js/nav-toggle.js","modified":1456764406860,"shasum":"78b59f1beb12adea0d7f9bcf4377cb699963f220"},{"_id":"public/js/motion_global.js","modified":1456764406862,"shasum":"367e329b2cc19c6b7634ea2917a218c84a22ec17"},{"_id":"public/js/motion_fallback.js","modified":1456764406864,"shasum":"a767d522c65a8b2fbad49135c9332135c6785c3e"},{"_id":"public/js/lazyload.js","modified":1456764406866,"shasum":"b92e9acdc7afc15468314c03f4a643b0c93944cf"},{"_id":"public/js/hook-duoshuo.js","modified":1456764406868,"shasum":"5f722b3967d50cc1e36efaa5e2a4a0ad464496b0"},{"_id":"public/js/helpers.js","modified":1456764406871,"shasum":"c2117b0ec653df4c45dd9d9575b190cbe1035335"},{"_id":"public/js/fancy-box.js","modified":1456764406876,"shasum":"c9782bfa8c1e51a8f8541530d836e75f48a433c2"},{"_id":"public/js/bootstrap.scrollspy.js","modified":1456764406878,"shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625"},{"_id":"public/images/searchicon.png","modified":1456764406886,"shasum":"67727a6a969be0b2659b908518fa6706eed307b8"},{"_id":"public/images/placeholder.gif","modified":1456764406893,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/loading.gif","modified":1456764406897,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/cc-zero.svg","modified":1456764406899,"shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030"},{"_id":"public/images/cc-by.svg","modified":1456764406901,"shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e"},{"_id":"public/images/cc-by-sa.svg","modified":1456764406906,"shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e"},{"_id":"public/images/cc-by-nd.svg","modified":1456764406917,"shasum":"c563508ce9ced1e66948024ba1153400ac0e0621"},{"_id":"public/images/cc-by-nc.svg","modified":1456764406922,"shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7"},{"_id":"public/images/cc-by-nc-sa.svg","modified":1456764406926,"shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e"},{"_id":"public/images/cc-by-nc-nd.svg","modified":1456764406930,"shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564"},{"_id":"public/images/bkdefault_avatar.jpg","modified":1456764406935,"shasum":"b687bb4bfbe35a32b592c24d652ba80cfdc770fc"},{"_id":"public/fonts/icon-linecons/selection.json","modified":1456764406949,"shasum":"68da6ea1b3ab9355d42694bf5745071cdefa4a65"},{"_id":"public/fonts/icon-linecons/icomoon.woff","modified":1456764406955,"shasum":"0b07ee6ceda3b1bceb40c1e7379b3aa48dcc15a8"},{"_id":"public/fonts/icon-linecons/icomoon.ttf","modified":1456764406957,"shasum":"078068206684e4f185b0187ad3cee16f54a287d7"},{"_id":"public/fonts/icon-linecons/icomoon.svg","modified":1456764406959,"shasum":"808eaf7d61f7e67c76976265c885e79c36920f0b"},{"_id":"public/fonts/icon-linecons/icomoon.eot","modified":1456764406962,"shasum":"e2d7f040428a632f3c50bfa94083b759936effc2"},{"_id":"public/fonts/icon-icomoon/icomoon.woff","modified":1456764406964,"shasum":"05f1ec0bd307da5e731a86eb4961589a6042aebb"},{"_id":"public/fonts/icon-icomoon/icomoon.ttf","modified":1456764406973,"shasum":"f399713d1c9400d4d3373e38991a7e362a754a94"},{"_id":"public/fonts/icon-icomoon/icomoon.svg","modified":1456764406979,"shasum":"e316347805eb93425faa678611c5e42a7152da8f"},{"_id":"public/fonts/icon-icomoon/icomoon.eot","modified":1456764406982,"shasum":"301fcf00c24750dddf1c529f944ca62c7f1a217d"},{"_id":"public/fonts/icon-fifty-shades/selection.json","modified":1456764406985,"shasum":"e5a5042e8e516b1d30fa3b1206d2c74921cec72b"},{"_id":"public/fonts/icon-fifty-shades/icomoon.woff","modified":1456764406987,"shasum":"4de6a74f523dee33d95dde61caae5809f9a5d448"},{"_id":"public/fonts/icon-fifty-shades/icomoon.ttf","modified":1456764406990,"shasum":"72fe82e1f3db52414eed706952d385af241cb196"},{"_id":"public/fonts/icon-fifty-shades/icomoon.svg","modified":1456764406992,"shasum":"1a4afd739e1f8eb8d430dbdd29e36a9999802e8d"},{"_id":"public/fonts/icon-fifty-shades/icomoon.eot","modified":1456764406994,"shasum":"da86ba5df72d1288de9e9633e5f528062dd427d5"},{"_id":"public/fonts/icon-feather/selection.json","modified":1456764406996,"shasum":"d95a90b0d541e48b049902090c0d008ad92b4115"},{"_id":"public/fonts/icon-feather/icomoon.woff","modified":1456764407010,"shasum":"2ea1c59c17422798e64ee6f4e9ce1f7aff1a06a5"},{"_id":"public/fonts/icon-feather/icomoon.ttf","modified":1456764407012,"shasum":"b2bbae4b613403cf61ad25037913378da1c07b8f"},{"_id":"public/fonts/icon-feather/icomoon.svg","modified":1456764407015,"shasum":"d5eb756eefda9b454dcb23c2b1cefd4051d18d41"},{"_id":"public/fonts/icon-feather/icomoon.eot","modified":1456764407018,"shasum":"11554b9e9d5b9f535ba96cbb27d45d8c8f1689fd"},{"_id":"public/fonts/icon-default/selection.json","modified":1456764407021,"shasum":"ff1b9b78eced4d0368d14cc192ac67a0dd498593"},{"_id":"public/fonts/icon-default/icomoon.woff","modified":1456764407027,"shasum":"dbe0368f2a65d87b13234cfea29d9783892fc7a8"},{"_id":"public/fonts/icon-default/icomoon.ttf","modified":1456764407034,"shasum":"c093408e6030221cafc1f79d897f1fb5283c1178"},{"_id":"public/fonts/icon-default/icomoon.svg","modified":1456764407042,"shasum":"f92ad8cddc250f0bb5ca466fca95d321987e127e"},{"_id":"public/fonts/icon-default/icomoon.eot","modified":1456764407044,"shasum":"90763e97be18be78e65749075225cceeddc6fa8a"},{"_id":"public/css/main.css","modified":1456764407498,"shasum":"31f4f04fef8ac80fd3f0ed398c87dbbb7707f16c"},{"_id":"public/CNAME","modified":1456764407680,"shasum":"fdebcf8f6827a8ea9cf1689042231fb685a49895"},{"_id":"public/tags/index.html","modified":1456764407792,"shasum":"4e821245971ebad80c598fef842c97cea7ff383d"},{"_id":"public/categories/index.html","modified":1456764407854,"shasum":"80dacb7be960ddd4d4b0c4d7670f3946d9623797"},{"_id":"public/about/index.html","modified":1456764407909,"shasum":"458fba1b7fd2221fdd62c219f9781fbc1033f805"},{"_id":"public/2016/02/22/modern-operating-systems-file-systems/index.html","modified":1456764407997,"shasum":"e32c751b1edde20bbb1a8c55e58e58de20a9dbe7"},{"_id":"public/2016/01/12/tcp-closed-without-fin/index.html","modified":1456764408103,"shasum":"7ef9c16cb9a10a4387a23363d73c6b98a6282bd8"},{"_id":"public/2015/12/11/java-fileio/index.html","modified":1456764408212,"shasum":"2995d06493a587778e767b883e23c3e10302bb2f"},{"_id":"public/2015/12/10/java-hold-objects/index.html","modified":1456764408289,"shasum":"a674234089b0337e023dc8e09677f853f4774cd1"},{"_id":"public/2015/12/08/java-commonclass/index.html","modified":1456764408358,"shasum":"9bd8c2cf0da93e2ce6dd3369199d68a1fb5041f7"},{"_id":"public/2015/12/06/java-string/index.html","modified":1456764408438,"shasum":"527aafe1ef8be7fb469bb5e2a61f4e40fc050d8c"},{"_id":"public/2015/12/05/java-exception/index.html","modified":1456764408499,"shasum":"0b31bdba3814ed88a28b5c58ec942a9362f1c985"},{"_id":"public/2015/12/01/java-polymorphism/index.html","modified":1456764408578,"shasum":"983d0e6f811f2825572b32d91c6f395146809361"},{"_id":"public/2015/11/07/universalreference/index.html","modified":1456764408662,"shasum":"138796c9327937b5eb4452a770e468bd22e1b7fd"},{"_id":"public/2015/10/31/special-member-function/index.html","modified":1456764408744,"shasum":"c35736cf825ca6c0d089adb9015d120c8d6af22f"},{"_id":"public/2015/10/20/cpp-rvo/index.html","modified":1456764408829,"shasum":"cfd7d7c645a94deed845187496c232cc85cd9092"},{"_id":"public/2015/10/12/DeducingType/index.html","modified":1456764408934,"shasum":"2968cfd8b1d55f743b2fc9026963b486acbee37d"},{"_id":"public/2015/10/12/singleton/index.html","modified":1456764409016,"shasum":"98746d66639b249832499f7fdc5e188b81f7d749"},{"_id":"public/2015/10/11/hihocoder-binarygraph/index.html","modified":1456764409120,"shasum":"49d48ce38cba9373268d36abb1b2a4f9c4a407c2"},{"_id":"public/2015/10/11/hihocoder-trie2/index.html","modified":1456764409233,"shasum":"f7843bd9bb22f9dae558cbf3fb93f07bf0a75b29"},{"_id":"public/2015/10/11/hihocoder-kmp/index.html","modified":1456764409299,"shasum":"7c946dfb78ce8a8b5bef82a47883195f5d2fc631"},{"_id":"public/2015/10/11/hihocoder-trie/index.html","modified":1456764409376,"shasum":"a8573b3f7c60c0e5424bc540b52b14e9f16a4d1e"},{"_id":"public/archives/index.html","modified":1456764409478,"shasum":"a57dd4f78c19b174e584dd724b648c5b5e799fa3"},{"_id":"public/archives/page/2/index.html","modified":1456764409547,"shasum":"a3a707595e7e4514a6a83131eee52d420bf2ebed"},{"_id":"public/archives/2015/index.html","modified":1456764409627,"shasum":"4eafc6aba92add2caa3bafc2c4d3cc00b137df10"},{"_id":"public/archives/2015/page/2/index.html","modified":1456764409699,"shasum":"ac553a5e3394644d298ab8f0817be161a003b59b"},{"_id":"public/archives/2015/10/index.html","modified":1456764409769,"shasum":"6508f6963fe1fa76ebb63c470e2badfa2b0d7a68"},{"_id":"public/archives/2015/11/index.html","modified":1456764409833,"shasum":"69f071f6efb0c25376384a09191e35949dc445bc"},{"_id":"public/archives/2015/12/index.html","modified":1456764409896,"shasum":"61dc5347c527449ca22b9e4c16de40332228d876"},{"_id":"public/archives/2016/index.html","modified":1456764410009,"shasum":"de5180f2d0daa2e8cf95dc793c956b61c335ac8a"},{"_id":"public/archives/2016/01/index.html","modified":1456764410123,"shasum":"da64c30581b6ea5f76471a8ffb395c88c2c452e7"},{"_id":"public/archives/2016/02/index.html","modified":1456764410218,"shasum":"175ad6cc29437866ba9b659f0c7cd5fcd2fb2c70"},{"_id":"public/categories/Effective-Modern-C/index.html","modified":1456764410300,"shasum":"6549fde51f30ffadab14e5ca80b7409b07a6b069"},{"_id":"public/categories/UNP/index.html","modified":1456764410386,"shasum":"5ae3d388cd196d684b51354fbd154babcb0755e2"},{"_id":"public/categories/design-pattern/index.html","modified":1456764410470,"shasum":"057a866c0b8808548e658f9d8acd6ee523e85454"},{"_id":"public/categories/Operating-Systems/index.html","modified":1456764410538,"shasum":"d1f7c770c370a5eeaad7f412be7d5a4cff85cac0"},{"_id":"public/categories/hihocoder/index.html","modified":1456764410696,"shasum":"93ca68d14a6edc8a3c6c346de75d71fc6b2ca38a"},{"_id":"public/categories/C/index.html","modified":1456764410782,"shasum":"6eef5788f7b6ff7d1905f9266f5b1cb91f4e7f51"},{"_id":"public/index.html","modified":1456764410934,"shasum":"27cfe129079e658acedef426687bbd3397f1eb34"},{"_id":"public/page/2/index.html","modified":1456764411109,"shasum":"129e98d3eab74a814ce755ac86aa4129750f5431"},{"_id":"public/tags/reference/index.html","modified":1456764411187,"shasum":"cdc59ed25a62e9f09461d852502814e8960f1255"},{"_id":"public/tags/C/index.html","modified":1456764411277,"shasum":"88e688be771d5fcd912016ee0bb67be644603367"},{"_id":"public/tags/universal-reference/index.html","modified":1456764411339,"shasum":"1b80aa3de94438ecfbc39115600642ea044c7255"},{"_id":"public/tags/Effective-Modern-C/index.html","modified":1456764411396,"shasum":"2f940a797ade5cc458fbc56c79455f01f50cce40"},{"_id":"public/tags/TCP/index.html","modified":1456764411466,"shasum":"f208e3a1bc01c7653a3c29dd87764e47fec7e913"},{"_id":"public/tags/socket/index.html","modified":1456764411519,"shasum":"fd6eaae441863900b34567a5c445f09de826deac"},{"_id":"public/tags/Linux/index.html","modified":1456764411571,"shasum":"c099a370af8ffeb20e67da288d7f3c476551d701"},{"_id":"public/tags/FIN/index.html","modified":1456764411621,"shasum":"bd19baf59888fbdb0990567f0f316268336f4d53"},{"_id":"public/tags/RST/index.html","modified":1456764411669,"shasum":"83805812e37ee4ba9d4df6ba2d2204cd26cf1bac"},{"_id":"public/tags/C-类型推导/index.html","modified":1456764411727,"shasum":"d5e1e01edf5431c922e17c248dd01ccd56aa3e58"},{"_id":"public/tags/template/index.html","modified":1456764411776,"shasum":"9cd99dfa485039cb1aa0114908244c73a3fd5b73"},{"_id":"public/tags/auto/index.html","modified":1456764411845,"shasum":"3de957edaa00b840995a1ea0e1399d9c54649aca"},{"_id":"public/tags/decltype/index.html","modified":1456764411893,"shasum":"f419cac5da3f262104b5da718dd60bc8f48c17b2"},{"_id":"public/tags/singleton/index.html","modified":1456764411932,"shasum":"27b393119b86c3a83f24be6c6b8bf1f728d26ec9"},{"_id":"public/tags/c/index.html","modified":1456764411992,"shasum":"245eb93fd097a1b559421e0ed0662444770425b4"},{"_id":"public/tags/design-pattern/index.html","modified":1456764412035,"shasum":"e6253eb80613e54fed236e7c4f69c38a8220ff31"},{"_id":"public/tags/设计模式/index.html","modified":1456764412075,"shasum":"752bdd1f5f1c6bb2de0424e5f82b75114a2226ca"},{"_id":"public/tags/单例模式/index.html","modified":1456764412120,"shasum":"e13f7bb5f97643aca9391e62bb104edc4f1f4c06"},{"_id":"public/tags/operating-system/index.html","modified":1456764412169,"shasum":"0dd38aac3ec982545687e46f8538b0502eb4bfe0"},{"_id":"public/tags/file-system/index.html","modified":1456764412218,"shasum":"429d0428995613275f4a5cf860a732f0d34c88cd"},{"_id":"public/tags/modern-operating-systems/index.html","modified":1456764412264,"shasum":"9a47b24c22511aac5bf7292c04d59a59461dec0e"},{"_id":"public/tags/string/index.html","modified":1456764412307,"shasum":"2129cd248dabe70ccb40f665f3370ccaa60f119e"},{"_id":"public/tags/java/index.html","modified":1456764412370,"shasum":"e7bcb3bb054570c084d3d2d0cdba5bc9678dac52"},{"_id":"public/tags/多态/index.html","modified":1456764412426,"shasum":"febeb837a68d69c85b2b54efac834355b63ad7e2"},{"_id":"public/tags/抽象类/index.html","modified":1456764412486,"shasum":"d4262111d6385aa24a19ec940238a1f6cac97faf"},{"_id":"public/tags/接口/index.html","modified":1456764412541,"shasum":"ccc6ba986b0e1eba358a87f4fadd4052e6bd5b46"},{"_id":"public/tags/generic/index.html","modified":1456764412590,"shasum":"32b391d46f54478a19f1031a72907d068df0fae0"},{"_id":"public/tags/object/index.html","modified":1456764412656,"shasum":"268a8a294b6b0e5c9b0e65f2788b9ed9e9c45a96"},{"_id":"public/tags/file/index.html","modified":1456764412714,"shasum":"424eac655a87faaa785d2350a58beed6d2cb7638"},{"_id":"public/tags/io/index.html","modified":1456764412768,"shasum":"6d950ae503489d84aea6ebc136c4a8aa83d21799"},{"_id":"public/tags/异常/index.html","modified":1456764412838,"shasum":"e78797e4ddb8c77e7ebceb97effe8f349a7ac25a"},{"_id":"public/tags/exception/index.html","modified":1456764412908,"shasum":"43cf652549f350ad139abd6b8277227769e68c63"},{"_id":"public/tags/hihocoder/index.html","modified":1456764412986,"shasum":"12f13d834c2e3c6b1b0a9c3b18f34ee90c2c5fc9"},{"_id":"public/tags/algorithm/index.html","modified":1456764413037,"shasum":"3ff4cbf1cdf35f5e1e9b855894c1294624ebd6ee"},{"_id":"public/tags/trie图/index.html","modified":1456764413076,"shasum":"b12226cbaa10b0f1535a49e96ef7dc083c14de10"},{"_id":"public/tags/trie树/index.html","modified":1456764413118,"shasum":"2a02ddcafe7a82805db4a88196816958cf25abab"},{"_id":"public/tags/字典树/index.html","modified":1456764413164,"shasum":"3dfa060b1dbda30db90388d2e1d5ac6b3e9fbe84"},{"_id":"public/tags/kmp/index.html","modified":1456764413200,"shasum":"692a0fef83bf1710383d967b0a71269486598d2a"},{"_id":"public/tags/next数组/index.html","modified":1456764413250,"shasum":"9350762d46cc27b10b86bcabf71c90ecc349ebba"},{"_id":"public/tags/二分图/index.html","modified":1456764413294,"shasum":"a5e289024c35a93e53786f57228aadeabc8391b7"},{"_id":"public/tags/二分图判定/index.html","modified":1456764413344,"shasum":"0939e003b082cd3cf76b96a420992646f4d2806f"},{"_id":"public/tags/最大匹配/index.html","modified":1456764413392,"shasum":"b5ec06982694a73100eab6bedf86de82b4be488c"},{"_id":"public/tags/RVO/index.html","modified":1456764413440,"shasum":"297c5e8102eec0e85323c95de9b7295f8a128300"},{"_id":"public/tags/返回值优化/index.html","modified":1456764413492,"shasum":"7a4e22dd4066314b66bee4ac9fd84e791350d40d"},{"_id":"public/tags/函数调用/index.html","modified":1456764413528,"shasum":"227eb66b40ccfa7a04a8d83313767d055fc82d20"},{"_id":"public/tags/栈帧/index.html","modified":1456764413564,"shasum":"c4dc5e8b898a71397086ee00047340b223424f4f"}],"Category":[{"name":"Effective Modern C++","_id":"cil87wwag0004d6jxkyp33c2a"},{"name":"UNP","_id":"cil87wwao000fd6jxc9w49r2x"},{"name":"design pattern","_id":"cil87wwaz0014d6jxny6xge73"},{"name":"Operating Systems","_id":"cil87wwb5001hd6jx68ujr4a4"},{"name":"hihocoder","_id":"cil87wwbz002ld6jxlv8i37s5"},{"name":"C++","_id":"cil87wwcj003od6jxasf248bh"}],"Data":[],"Page":[{"title":"ALL tags","date":"2015-10-11T07:29:14.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: ALL tags\ndate: 2015-10-11 15:29:14\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-02-28T12:41:25.000Z","path":"tags/index.html","layout":"page","_id":"cil87wwa50000d6jx34q19z2t"},{"title":"分类","date":"2015-10-11T07:23:02.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: 分类\ndate: 2015-10-11 15:23:02\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-02-28T12:41:25.000Z","path":"categories/index.html","layout":"page","_id":"cil87wwa80001d6jx644nwcvl"},{"title":"about","date":"2015-10-11T07:33:19.000Z","_content":"\n这是我的个人博客，用来记录一些学习的东西和搭个博客玩玩！\n\n内容简单，如有错误还请指出！谢谢\n\n截至现在为止很多内容都不是原创，主要还是看了其他东西做一些记录，但是都会注明出处的\n\n\n博客使用hexo搭建 https://hexo.io/\n\nnext主题：https://github.com/iissnan/hexo-theme-next   常见问题 https://github.com/iissnan/hexo-theme-next/wiki\n\n个人邮箱： xiejun901@gmail.com","source":"about/index.md","raw":"title: about\ndate: 2015-10-11 15:33:19\n---\n\n这是我的个人博客，用来记录一些学习的东西和搭个博客玩玩！\n\n内容简单，如有错误还请指出！谢谢\n\n截至现在为止很多内容都不是原创，主要还是看了其他东西做一些记录，但是都会注明出处的\n\n\n博客使用hexo搭建 https://hexo.io/\n\nnext主题：https://github.com/iissnan/hexo-theme-next   常见问题 https://github.com/iissnan/hexo-theme-next/wiki\n\n个人邮箱： xiejun901@gmail.com","updated":"2016-02-28T12:41:25.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cil87wwa90002d6jxpwarn9tv"}],"Post":[{"title":"C++ 中的 universal reference","date":"2015-11-07T13:34:04.000Z","_content":"\n之前看类型推导时，看到了 universal reference 这个词，之前完全不知道这是啥意思，看到后面才知道，按照 Scott Meyers 书上所说，这样称呼的原因如下\n\n*In fact, “T&&” has two different meanings. One is rvalue reference, of course. Such references behave exactly the way you expect: they bind only to rvalues, and their primary raison d’être is to identify objects that may be moved from. \nThe other meaning for “T&&” is either rvalue reference or lvalue reference. Such references look like rvalue references in the source code (i.e., “T&&”), but they can behave as if they were lvalue references (i.e., “T&”). Their dual nature permits them to bind to rvalues (like rvalue references) as well as lvalues (like lvalue references). Furthermore, they can bind to const or non-const objects, to volatile or non-volatile objects, even to objects that are both const and volatile. They can bind to virtually anything. Such unprecedentedly flexible references deserve a name of their own. I call them universal references.1*\n*1 Item 25 explains that universal references should almost always have std::forward applied to them, and as this book goes to press, some members of the C++ community have started referring to universal references as forwarding references.*","source":"_posts/universalreference.md","raw":"title: C++ 中的 universal reference\ndate: 2015-11-07 21:34:04\ncategories: Effective Modern C++\ntags: [reference, C++, universal reference, Effective Modern C++, ]\n---\n\n之前看类型推导时，看到了 universal reference 这个词，之前完全不知道这是啥意思，看到后面才知道，按照 Scott Meyers 书上所说，这样称呼的原因如下\n\n*In fact, “T&&” has two different meanings. One is rvalue reference, of course. Such references behave exactly the way you expect: they bind only to rvalues, and their primary raison d’être is to identify objects that may be moved from. \nThe other meaning for “T&&” is either rvalue reference or lvalue reference. Such references look like rvalue references in the source code (i.e., “T&&”), but they can behave as if they were lvalue references (i.e., “T&”). Their dual nature permits them to bind to rvalues (like rvalue references) as well as lvalues (like lvalue references). Furthermore, they can bind to const or non-const objects, to volatile or non-volatile objects, even to objects that are both const and volatile. They can bind to virtually anything. Such unprecedentedly flexible references deserve a name of their own. I call them universal references.1*\n*1 Item 25 explains that universal references should almost always have std::forward applied to them, and as this book goes to press, some members of the C++ community have started referring to universal references as forwarding references.*","slug":"universalreference","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwab0003d6jxl2bzo2tq"},{"title":"Linux 下 TCP 连接断开未发送 FIN","date":"2016-01-11T16:36:51.000Z","_content":"\n最近写一个简单的聊天服务器时候， 看了UNP上通过带外数据想实现心跳的例子，就尝试了使用一下，然后之前好好的客户端崩溃掉服务端也能正常处理，加了这块代码之后客户端崩溃服务端也会得到 Connection reset by peer 的错误。 \n经过各种纠结， 最后在群友的帮助下，发现了是由于在Linux下，如果TCP接收缓冲区中由数据，那么此时调用close，便不会发送Fin， 会直接发送RST。由于通过select监听带外数据异常，在通知带外数据异常时，虽然调用recv(1, MSG_OOB)读走了带外数据，但是由于没有调用普通的读数据，还是会被当做缓冲区由数据，直接发送RST而不发送FIN\n在这儿记录以下找到问题的过程\n\n\n简化了的出问题的代码\n\n```python\n# 客户端代码\nimport socket\nimport time\nimport select\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind(('localhost', 8081))\nsock.connect(('localhost', 8080))\nconnections = {}\nconnections[sock.fileno()] = sock\nexpires = time.time()\nwhile True:\n    r = []\n    e = []\n    for fileno, conn in connections.items():\n        r.append(fileno)\n        e.append(fileno)\n    r, w, e = select.select(r, [], e, 1)\n    for fileno in r:\n        conn = connections[fileno]\n        print(conn.recv(1024))\n    for fileno in e:\n        conn = connections[fileno]\n        print(conn.recv(1, socket.MSG_OOB))\n    current = time.time()\n    while current> expires:\n        expires += 1000\n        sock.send('c', socket.MSG_OOB)\n\t\t\n# 服务端代码\nimport socket\nimport select\n\ntry:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.setblocking(0)\n    sock.bind(('localhost', 8080))\n    sock.listen(5)\n    connections = {}\n    connections[sock.fileno()] = sock\n    while True:\n        r = []\n        w = []\n        e = []\n        for fileno, conn in connections.items():\n            r.append(fileno)\n            e.append(fileno)\n        r, w, e = select.select(r, w, e)\n        for fileno in r:\n            conn = connections[fileno]\n            if conn == sock:\n                conn, addr = sock.accept()\n                connections[conn.fileno()] = conn\n            else:\n                data = conn.recv(1024)\n                if data is None:\n                    conn.close()\n                    del connections[fileno]\n        for fileno in e:\n            conn = connections[fileno]\n            print(conn.recv(1, socket.MSG_OOB))\n            conn.send('c', socket.MSG_OOB)\nfinally:\n    sock.close()\n```\n\n遇到问题之后，想了各种可能的情况，比如对方已经发送FIN了，还朝对方发送了数据或者接收了数据之类的，最后想到好像有个tcpdump命令可以看tcp的通信情况，就使用这个命令看了以下tcp双方收发的数据情况，发现client只发送了RST没发送FIN，这和之前印象中看到的结束进程会发送FIN不符啊，翻了翻UNP、确实没找到相关内容，就去某群里问了一下什么时候会出现不发送FIN\n\n\t03:04:09.137374 IP localhost.tproxy > localhost.http-alt: Flags [S], seq 2126650160, win 43690, options [mss 65495,sackOK,TS val 113521554 ecr 0,nop,wscale 7], length 0\n\t03:04:09.137415 IP localhost.http-alt > localhost.tproxy: Flags [S.], seq 2461040723, ack 2126650161, win 43690, options [mss 65495,sackOK,TS val 113521555 ecr 113521554,nop,wscale 7], length 0\n\t03:04:09.137446 IP localhost.tproxy > localhost.http-alt: Flags [.], ack 1, win 342, options [nop,nop,TS val 113521555 ecr 113521555], length 0\n\t03:04:10.137866 IP localhost.tproxy > localhost.http-alt: Flags [P.U], seq 1:2, ack 1, win 342, urg 1, options [nop,nop,TS val 113521805 ecr 113521555], length 1\n\t03:04:10.137976 IP localhost.http-alt > localhost.tproxy: Flags [.], ack 2, win 342, options [nop,nop,TS val 113521805 ecr 113521805], length 0\n\t03:04:10.138218 IP localhost.http-alt > localhost.tproxy: Flags [P.U], seq 1:2, ack 2, win 342, urg 1, options [nop,nop,TS val 113521805 ecr 113521805], length 1\n\t03:04:10.138258 IP localhost.tproxy > localhost.http-alt: Flags [.], ack 2, win 342, options [nop,nop,TS val 113521805 ecr 113521805], length 0\n\t03:04:37.620543 IP localhost.tproxy > localhost.http-alt: Flags [R.], seq 2, ack 2, win 342, options [nop,nop,TS val 113528675 ecr 113521805], length 0\n\t\n从上面的tcpdump信息可以发现，客户端发起连接后，向服务端发送了SYN， 服务端回 SYN+ACK， 客户端回ACK， 客户端发送带外数据，服务端收到带外数据发送ACK， 服务端发送带外数据，客户端收到带外数据回复ACK， 然后此时我kill掉了客户端进程，此时并没有发送FIN， 直接发送了RST，此时服务端的select会检测到可读事件，调用recv读取一个已经接收到RST的socket就会报ECONNRESET错误\n\n后面有人提出了说在Linux下，如果TCP缓冲区里还由内容没吸干净，调用close就会出现发送RST而不发送FIN的情况，还给出了代码复现，找到了源代码中相关内容，然后其他人还找出了相关文档 [TCP RST: Calling close() on a socket with data in the receive queue](http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/TCPRST.pdf)\n\n\n如下代码, 使用tcpdump 也出现了同样的问题\n\n```C\n//client\nint main() {\n    char buff[] = \"hello\";\n    int clientfd = socket(AF_INET, SOCK_STREAM, 0);\n    sockaddr_in serveraddr;\n    bzero(&serveraddr, sizeof(serveraddr));\n    serveraddr.sin_family = AF_INET;\n    serveraddr.sin_port = htons(8080);\n    inet_pton(AF_INET, \"127.0.0.1\", &serveraddr.sin_addr);\n    connect(clientfd, (struct sockaddr* )&serveraddr, sizeof(serveraddr));\n    sleep(3);\n    //send(clientfd, buff, strlen(buff), 0);\n    close(clientfd);\n    return 0;\n}\n\n//server \nint main() {\n    char buff[10]=\"hello\";\n    bzero(buff, sizeof(buff));\n    int listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    sockaddr_in serveraddr;\n    bzero(&serveraddr, sizeof(serveraddr));\n    serveraddr.sin_family = AF_INET;\n    serveraddr.sin_port = htons(8080);\n    inet_pton(AF_INET, \"127.0.0.1\", &serveraddr.sin_addr);\n    bind(listenfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));\n    listen(listenfd, 5);\n    sockaddr_in cliaddr;\n    socklen_t len;\n    int connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &len);\n    //int n = recv(connfd, buff, 10, 0);\n    send(connfd, buff, strlen(buff), 0);\n    //buff[n] = 0;\n    cout<<buff<<endl;\n    close(listenfd);\n    close(connfd);\n    return 0;\n}\n```\n\n如果修改客户端代码读取掉数据就能正常的发送FIN， \n\n在 /net/ipv4/tcp.c 中2063行左右有相关逻辑， 估摸着发送了带外数据，调用recv(fd, 1, MSG_OOB) 并不能让 data_was_unread 为 0， 具体细节可能得更后面再去了解了\n\n```c\n\twhile ((skb = __skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tu32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq;\n\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\tlen--;\n\t\tdata_was_unread += len;\n\t\t__kfree_skb(skb);\n\t}\n\n\tsk_mem_reclaim(sk);\n\n\t/* If socket has been already reset (e.g. in tcp_reset()) - kill it. */\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto adjudge_to_death;\n\n\t/* As outlined in RFC 2525, section 2.17, we send a RST here because\n\t * data was lost. To witness the awful effects of the old behavior of\n\t * always doing a FIN, run an older 2.1.x kernel or 2.0.x, start a bulk\n\t * GET in an FTP client, suspend the process, wait for the client to\n\t * advertise a zero window, then kill -9 the FTP client, wheee...\n\t * Note: timeout is always zero in such a case.\n\t */\n\tif (unlikely(tcp_sk(sk)->repair)) {\n\t\tsk->sk_prot->disconnect(sk, 0);\n\t} else if (data_was_unread) {\n\t\t/* Unread data was tossed, zap the connection. */\n\t\tNET_INC_STATS_USER(sock_net(sk), LINUX_MIB_TCPABORTONCLOSE);\n\t\ttcp_set_state(sk, TCP_CLOSE);\n\t\ttcp_send_active_reset(sk, sk->sk_allocation);\n\t} else if (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime) {\n\t\t/* Check zero linger _after_ checking for unread data. */\n\t\tsk->sk_prot->disconnect(sk, 0);\n\t\tNET_INC_STATS_USER(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t} else if (tcp_close_state(sk)) {\n```","source":"_posts/tcp-closed-without-fin.md","raw":"title: Linux 下 TCP 连接断开未发送 FIN\ndate: 2016-01-12 00:36:51\ntags: [TCP, socket, Linux, FIN, RST]\ncategories: UNP\n---\n\n最近写一个简单的聊天服务器时候， 看了UNP上通过带外数据想实现心跳的例子，就尝试了使用一下，然后之前好好的客户端崩溃掉服务端也能正常处理，加了这块代码之后客户端崩溃服务端也会得到 Connection reset by peer 的错误。 \n经过各种纠结， 最后在群友的帮助下，发现了是由于在Linux下，如果TCP接收缓冲区中由数据，那么此时调用close，便不会发送Fin， 会直接发送RST。由于通过select监听带外数据异常，在通知带外数据异常时，虽然调用recv(1, MSG_OOB)读走了带外数据，但是由于没有调用普通的读数据，还是会被当做缓冲区由数据，直接发送RST而不发送FIN\n在这儿记录以下找到问题的过程\n\n\n简化了的出问题的代码\n\n```python\n# 客户端代码\nimport socket\nimport time\nimport select\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind(('localhost', 8081))\nsock.connect(('localhost', 8080))\nconnections = {}\nconnections[sock.fileno()] = sock\nexpires = time.time()\nwhile True:\n    r = []\n    e = []\n    for fileno, conn in connections.items():\n        r.append(fileno)\n        e.append(fileno)\n    r, w, e = select.select(r, [], e, 1)\n    for fileno in r:\n        conn = connections[fileno]\n        print(conn.recv(1024))\n    for fileno in e:\n        conn = connections[fileno]\n        print(conn.recv(1, socket.MSG_OOB))\n    current = time.time()\n    while current> expires:\n        expires += 1000\n        sock.send('c', socket.MSG_OOB)\n\t\t\n# 服务端代码\nimport socket\nimport select\n\ntry:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.setblocking(0)\n    sock.bind(('localhost', 8080))\n    sock.listen(5)\n    connections = {}\n    connections[sock.fileno()] = sock\n    while True:\n        r = []\n        w = []\n        e = []\n        for fileno, conn in connections.items():\n            r.append(fileno)\n            e.append(fileno)\n        r, w, e = select.select(r, w, e)\n        for fileno in r:\n            conn = connections[fileno]\n            if conn == sock:\n                conn, addr = sock.accept()\n                connections[conn.fileno()] = conn\n            else:\n                data = conn.recv(1024)\n                if data is None:\n                    conn.close()\n                    del connections[fileno]\n        for fileno in e:\n            conn = connections[fileno]\n            print(conn.recv(1, socket.MSG_OOB))\n            conn.send('c', socket.MSG_OOB)\nfinally:\n    sock.close()\n```\n\n遇到问题之后，想了各种可能的情况，比如对方已经发送FIN了，还朝对方发送了数据或者接收了数据之类的，最后想到好像有个tcpdump命令可以看tcp的通信情况，就使用这个命令看了以下tcp双方收发的数据情况，发现client只发送了RST没发送FIN，这和之前印象中看到的结束进程会发送FIN不符啊，翻了翻UNP、确实没找到相关内容，就去某群里问了一下什么时候会出现不发送FIN\n\n\t03:04:09.137374 IP localhost.tproxy > localhost.http-alt: Flags [S], seq 2126650160, win 43690, options [mss 65495,sackOK,TS val 113521554 ecr 0,nop,wscale 7], length 0\n\t03:04:09.137415 IP localhost.http-alt > localhost.tproxy: Flags [S.], seq 2461040723, ack 2126650161, win 43690, options [mss 65495,sackOK,TS val 113521555 ecr 113521554,nop,wscale 7], length 0\n\t03:04:09.137446 IP localhost.tproxy > localhost.http-alt: Flags [.], ack 1, win 342, options [nop,nop,TS val 113521555 ecr 113521555], length 0\n\t03:04:10.137866 IP localhost.tproxy > localhost.http-alt: Flags [P.U], seq 1:2, ack 1, win 342, urg 1, options [nop,nop,TS val 113521805 ecr 113521555], length 1\n\t03:04:10.137976 IP localhost.http-alt > localhost.tproxy: Flags [.], ack 2, win 342, options [nop,nop,TS val 113521805 ecr 113521805], length 0\n\t03:04:10.138218 IP localhost.http-alt > localhost.tproxy: Flags [P.U], seq 1:2, ack 2, win 342, urg 1, options [nop,nop,TS val 113521805 ecr 113521805], length 1\n\t03:04:10.138258 IP localhost.tproxy > localhost.http-alt: Flags [.], ack 2, win 342, options [nop,nop,TS val 113521805 ecr 113521805], length 0\n\t03:04:37.620543 IP localhost.tproxy > localhost.http-alt: Flags [R.], seq 2, ack 2, win 342, options [nop,nop,TS val 113528675 ecr 113521805], length 0\n\t\n从上面的tcpdump信息可以发现，客户端发起连接后，向服务端发送了SYN， 服务端回 SYN+ACK， 客户端回ACK， 客户端发送带外数据，服务端收到带外数据发送ACK， 服务端发送带外数据，客户端收到带外数据回复ACK， 然后此时我kill掉了客户端进程，此时并没有发送FIN， 直接发送了RST，此时服务端的select会检测到可读事件，调用recv读取一个已经接收到RST的socket就会报ECONNRESET错误\n\n后面有人提出了说在Linux下，如果TCP缓冲区里还由内容没吸干净，调用close就会出现发送RST而不发送FIN的情况，还给出了代码复现，找到了源代码中相关内容，然后其他人还找出了相关文档 [TCP RST: Calling close() on a socket with data in the receive queue](http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/TCPRST.pdf)\n\n\n如下代码, 使用tcpdump 也出现了同样的问题\n\n```C\n//client\nint main() {\n    char buff[] = \"hello\";\n    int clientfd = socket(AF_INET, SOCK_STREAM, 0);\n    sockaddr_in serveraddr;\n    bzero(&serveraddr, sizeof(serveraddr));\n    serveraddr.sin_family = AF_INET;\n    serveraddr.sin_port = htons(8080);\n    inet_pton(AF_INET, \"127.0.0.1\", &serveraddr.sin_addr);\n    connect(clientfd, (struct sockaddr* )&serveraddr, sizeof(serveraddr));\n    sleep(3);\n    //send(clientfd, buff, strlen(buff), 0);\n    close(clientfd);\n    return 0;\n}\n\n//server \nint main() {\n    char buff[10]=\"hello\";\n    bzero(buff, sizeof(buff));\n    int listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    sockaddr_in serveraddr;\n    bzero(&serveraddr, sizeof(serveraddr));\n    serveraddr.sin_family = AF_INET;\n    serveraddr.sin_port = htons(8080);\n    inet_pton(AF_INET, \"127.0.0.1\", &serveraddr.sin_addr);\n    bind(listenfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));\n    listen(listenfd, 5);\n    sockaddr_in cliaddr;\n    socklen_t len;\n    int connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &len);\n    //int n = recv(connfd, buff, 10, 0);\n    send(connfd, buff, strlen(buff), 0);\n    //buff[n] = 0;\n    cout<<buff<<endl;\n    close(listenfd);\n    close(connfd);\n    return 0;\n}\n```\n\n如果修改客户端代码读取掉数据就能正常的发送FIN， \n\n在 /net/ipv4/tcp.c 中2063行左右有相关逻辑， 估摸着发送了带外数据，调用recv(fd, 1, MSG_OOB) 并不能让 data_was_unread 为 0， 具体细节可能得更后面再去了解了\n\n```c\n\twhile ((skb = __skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tu32 len = TCP_SKB_CB(skb)->end_seq - TCP_SKB_CB(skb)->seq;\n\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\tlen--;\n\t\tdata_was_unread += len;\n\t\t__kfree_skb(skb);\n\t}\n\n\tsk_mem_reclaim(sk);\n\n\t/* If socket has been already reset (e.g. in tcp_reset()) - kill it. */\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto adjudge_to_death;\n\n\t/* As outlined in RFC 2525, section 2.17, we send a RST here because\n\t * data was lost. To witness the awful effects of the old behavior of\n\t * always doing a FIN, run an older 2.1.x kernel or 2.0.x, start a bulk\n\t * GET in an FTP client, suspend the process, wait for the client to\n\t * advertise a zero window, then kill -9 the FTP client, wheee...\n\t * Note: timeout is always zero in such a case.\n\t */\n\tif (unlikely(tcp_sk(sk)->repair)) {\n\t\tsk->sk_prot->disconnect(sk, 0);\n\t} else if (data_was_unread) {\n\t\t/* Unread data was tossed, zap the connection. */\n\t\tNET_INC_STATS_USER(sock_net(sk), LINUX_MIB_TCPABORTONCLOSE);\n\t\ttcp_set_state(sk, TCP_CLOSE);\n\t\ttcp_send_active_reset(sk, sk->sk_allocation);\n\t} else if (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime) {\n\t\t/* Check zero linger _after_ checking for unread data. */\n\t\tsk->sk_prot->disconnect(sk, 0);\n\t\tNET_INC_STATS_USER(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t} else if (tcp_close_state(sk)) {\n```","slug":"tcp-closed-without-fin","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwam000ed6jx61ojmycy"},{"title":"C++中特殊的成员函数","date":"2015-10-31T08:13:06.000Z","_content":"\n本篇大概介绍一下C++中特殊的成员函数的生成规则\n\n在C++98中，有几个可能会被编译器自动生成的成员函数\n1. 构造函数\n2. 拷贝构造函数\n3. 拷贝赋值运算符\n4. 析构函数\n\n在C++11中，又增加了两个\n\n5. 移动构造函数\n6. 移动赋值运算符\n\n这些函数在你自己未进行申明的时候可能会被编译器自动生成，按照以下规则\n\n总结一下编译器会为生成默认的成员函数的条件\n\n#### 构造函数\n\n1. 无自定义的构造函数(包括拷贝构造函数和移动构造函数)\n\n#### 拷贝构造函数\n\n1. 无自定义的拷贝构造函数\n2. 无自定义的移动构造函数和移动赋值运算符\n\n#### 拷贝赋值运算符\n\n1. 无自定义的拷贝构造运算符\n2. 无自定义的移动构造函数和移动赋值运算符\n\n#### 移动构造函数和移动赋值运算符\n\n移动构造函数和移动赋值运算符是一块的，只要自定定义了其中一个，编译器就不会生成默认的移动构造函数或者移动赋值运算符\n\n1. 无自定义的移动构造函数和移动赋值运算符\n2. 无自定义的拷贝构造函数和拷贝赋值运算符\n3. 无自定义析构函数\n\n#### 析构函数\n\n1. 无自定义的析构函数\n\n#### 三/五法则\n\n三：对于C++98，对于拷贝构造函数，拷贝赋值运算符，析构函数这三者，只要定义了其中一个，那么这三个都应该一起被定义，因为一旦牵涉到其中一个，就牵涉到资源管理，那么另外两个通常也不能按照编译器生成的默认行为进行。\n五：对于C++11，又多了两个，移动构造函数，移动赋值运算符。同样的，这两个函数也应该加为一体。由于牵涉到自定义析构，拷贝，那么就牵涉到资源管理，因此移动赋值运算符和移动构造函数也需要自己定义，在这种情况下，由于默认的移动操作基本肯定是有问题的，因此编译器是不会为你生成默认的移动操作函数的。","source":"_posts/special-member-function.md","raw":"title: C++中特殊的成员函数\ndate: 2015-10-31 16:13:06\ncategories: Effective Modern C++\ntags: [C++, Effective Modern C++, C++类型推导, template, auto, decltype]\n---\n\n本篇大概介绍一下C++中特殊的成员函数的生成规则\n\n在C++98中，有几个可能会被编译器自动生成的成员函数\n1. 构造函数\n2. 拷贝构造函数\n3. 拷贝赋值运算符\n4. 析构函数\n\n在C++11中，又增加了两个\n\n5. 移动构造函数\n6. 移动赋值运算符\n\n这些函数在你自己未进行申明的时候可能会被编译器自动生成，按照以下规则\n\n总结一下编译器会为生成默认的成员函数的条件\n\n#### 构造函数\n\n1. 无自定义的构造函数(包括拷贝构造函数和移动构造函数)\n\n#### 拷贝构造函数\n\n1. 无自定义的拷贝构造函数\n2. 无自定义的移动构造函数和移动赋值运算符\n\n#### 拷贝赋值运算符\n\n1. 无自定义的拷贝构造运算符\n2. 无自定义的移动构造函数和移动赋值运算符\n\n#### 移动构造函数和移动赋值运算符\n\n移动构造函数和移动赋值运算符是一块的，只要自定定义了其中一个，编译器就不会生成默认的移动构造函数或者移动赋值运算符\n\n1. 无自定义的移动构造函数和移动赋值运算符\n2. 无自定义的拷贝构造函数和拷贝赋值运算符\n3. 无自定义析构函数\n\n#### 析构函数\n\n1. 无自定义的析构函数\n\n#### 三/五法则\n\n三：对于C++98，对于拷贝构造函数，拷贝赋值运算符，析构函数这三者，只要定义了其中一个，那么这三个都应该一起被定义，因为一旦牵涉到其中一个，就牵涉到资源管理，那么另外两个通常也不能按照编译器生成的默认行为进行。\n五：对于C++11，又多了两个，移动构造函数，移动赋值运算符。同样的，这两个函数也应该加为一体。由于牵涉到自定义析构，拷贝，那么就牵涉到资源管理，因此移动赋值运算符和移动构造函数也需要自己定义，在这种情况下，由于默认的移动操作基本肯定是有问题的，因此编译器是不会为你生成默认的移动操作函数的。","slug":"special-member-function","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwas000rd6jx8bq5fz9d"},{"title":"singleton 单例模式","date":"2015-10-12T13:07:59.000Z","_content":"\n单例模式是一种常见的面向对象设计模式，这里大概总结一下c++中单例模式的实现\n\n在C++中，单例模式通常采用模板实现，一个最基本的实现如下\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T& getInstance() {\n        static T _instance;\n        return _instance;\n    }\nprivate:\n    singleton();\n    singleton(const singleton&);\n    singleton &operator=(const singleton&);\n    ~singleton();\n};\n```\n\n使用方法为 singleton<Widget>::instance.fun(); 函数内的静态局部变量在第一次调用时初始化，但是这个方法对于c++11以前的标准是非线程安全的，标准并未规定多线程中对于静态局部变量的处理\n那很自然的办法就是加锁\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T& getInstance() {\n        std::lock_guard<std::mutex> lock(_m);\n        static T _instance;\n        return _instance;\n    }\nprivate:\n    static std::mutex _m;\n    singleton();\n    singleton(const singleton&);\n    singleton &operator=(const singleton&);\n    ~singleton();\n};\ntemplate<typename T>\nstd::mutex singleton<T>::_m;\n\n```\n\n但是按照这种方式，每次调用getInstance都要枷锁会导致效率底下，因此人们又采用了一个两次加锁(DCL)的方法\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T& getInstance() {\n        if (nullptr == _instance) {\n            std::lock_guard<std::mutex> lock(_m);\n            if (nullptr == _instance) {\n                _instance = new T();\n            }\n        }\n        return *_instance;\n    }\nprivate:\n    static std::mutex _m;\n    static T *_instance;\n    singleton();\n    singleton(const singleton&);\n    singleton &operator=(const singleton&);\n    ~singleton();\n};\ntemplate<typename T>\nstd::mutex singleton<T>::_m;\ntemplate<typename T>\nT *singleton<T>::_instance=nullptr;\n\n```\n\n但是由于乱序执行的影响，即由于编译器的优化等，会导致程序实际执行的顺序发生变化，DCL也不能完全保证线程安全，(1. 陈硕：LINUX多线程服务端编程 2. http://www.cs.wustl.edu/~schmidt/PDF/DC-Locking.pdf)，这个时候就需要加入\nmemeory barrier来保证程序的顺序执行\n\n\n如下给出一个在linux系统上可用的通过pthread_once来实现的线程安全的单例模式,通过pthread库来保证初始化只被执行一次\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T *instance() {\n        pthread_once(&_once, &singleton::init)\n        return _instance;\n    }\nprivate:\n    static pthread_once_t _once;\n    static void init(){\n        _instance = new T();\n    }\n    \n    static T *_instance;\n    singleton() = delete;\n    ~singleton() = delete;\n    singleton(const singleton &) = delete;\n};\ntemplate<typename T>\nT * singleton<T>::_instance=nullptr;\ntemplate<typename T>\npthread_once_t singleton<T>::_once=PTHREAD_ONCE_INIT;\n```\n\n不过对于C++11 ,标准中明确规定了静态局部变量在多线程下的处理方式，因此可以直接依靠编译器来保证只被初始化一次，因此就又回到了最初的版本~\n\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T& getInstance() {\n        static T _instance;\n        return _instance;\n    }\nprivate:\n    singleton();\n    singleton(const singleton&);\n    singleton &operator=(const singleton&);\n    ~singleton();\n};\n```\n\n提供一些参考资料\n\n[C++ and the Perils of Double-Checked Locking](http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf) 翻译为中文的：[C++和双重检查锁定模式(DCLP)的风险](http://blog.jobbole.com/86392/)\n\n[Double-Checked Locking is Fixed In C++11](http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/)  中文：[C++11 修复了双重检查锁定问题](http://blog.jobbole.com/52164/)\n\n[ C++中线程安全并且高效的singleton](http://www.klayge.org/2015/04/27/c%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%B9%B6%E4%B8%94%E9%AB%98%E6%95%88%E7%9A%84singleton/)\n\n[知乎的一些讨论](http://www.zhihu.com/question/35522476)","source":"_posts/singleton.md","raw":"title: singleton 单例模式\ndate: 2015-10-12 21:07:59\ntags: [singleton, c++, design pattern, 设计模式, 单例模式]\ncategories: design pattern\n---\n\n单例模式是一种常见的面向对象设计模式，这里大概总结一下c++中单例模式的实现\n\n在C++中，单例模式通常采用模板实现，一个最基本的实现如下\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T& getInstance() {\n        static T _instance;\n        return _instance;\n    }\nprivate:\n    singleton();\n    singleton(const singleton&);\n    singleton &operator=(const singleton&);\n    ~singleton();\n};\n```\n\n使用方法为 singleton<Widget>::instance.fun(); 函数内的静态局部变量在第一次调用时初始化，但是这个方法对于c++11以前的标准是非线程安全的，标准并未规定多线程中对于静态局部变量的处理\n那很自然的办法就是加锁\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T& getInstance() {\n        std::lock_guard<std::mutex> lock(_m);\n        static T _instance;\n        return _instance;\n    }\nprivate:\n    static std::mutex _m;\n    singleton();\n    singleton(const singleton&);\n    singleton &operator=(const singleton&);\n    ~singleton();\n};\ntemplate<typename T>\nstd::mutex singleton<T>::_m;\n\n```\n\n但是按照这种方式，每次调用getInstance都要枷锁会导致效率底下，因此人们又采用了一个两次加锁(DCL)的方法\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T& getInstance() {\n        if (nullptr == _instance) {\n            std::lock_guard<std::mutex> lock(_m);\n            if (nullptr == _instance) {\n                _instance = new T();\n            }\n        }\n        return *_instance;\n    }\nprivate:\n    static std::mutex _m;\n    static T *_instance;\n    singleton();\n    singleton(const singleton&);\n    singleton &operator=(const singleton&);\n    ~singleton();\n};\ntemplate<typename T>\nstd::mutex singleton<T>::_m;\ntemplate<typename T>\nT *singleton<T>::_instance=nullptr;\n\n```\n\n但是由于乱序执行的影响，即由于编译器的优化等，会导致程序实际执行的顺序发生变化，DCL也不能完全保证线程安全，(1. 陈硕：LINUX多线程服务端编程 2. http://www.cs.wustl.edu/~schmidt/PDF/DC-Locking.pdf)，这个时候就需要加入\nmemeory barrier来保证程序的顺序执行\n\n\n如下给出一个在linux系统上可用的通过pthread_once来实现的线程安全的单例模式,通过pthread库来保证初始化只被执行一次\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T *instance() {\n        pthread_once(&_once, &singleton::init)\n        return _instance;\n    }\nprivate:\n    static pthread_once_t _once;\n    static void init(){\n        _instance = new T();\n    }\n    \n    static T *_instance;\n    singleton() = delete;\n    ~singleton() = delete;\n    singleton(const singleton &) = delete;\n};\ntemplate<typename T>\nT * singleton<T>::_instance=nullptr;\ntemplate<typename T>\npthread_once_t singleton<T>::_once=PTHREAD_ONCE_INIT;\n```\n\n不过对于C++11 ,标准中明确规定了静态局部变量在多线程下的处理方式，因此可以直接依靠编译器来保证只被初始化一次，因此就又回到了最初的版本~\n\n\n```c++\ntemplate<typename T>\nclass singleton {\npublic:\n    static T& getInstance() {\n        static T _instance;\n        return _instance;\n    }\nprivate:\n    singleton();\n    singleton(const singleton&);\n    singleton &operator=(const singleton&);\n    ~singleton();\n};\n```\n\n提供一些参考资料\n\n[C++ and the Perils of Double-Checked Locking](http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf) 翻译为中文的：[C++和双重检查锁定模式(DCLP)的风险](http://blog.jobbole.com/86392/)\n\n[Double-Checked Locking is Fixed In C++11](http://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/)  中文：[C++11 修复了双重检查锁定问题](http://blog.jobbole.com/52164/)\n\n[ C++中线程安全并且高效的singleton](http://www.klayge.org/2015/04/27/c%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%B9%B6%E4%B8%94%E9%AB%98%E6%95%88%E7%9A%84singleton/)\n\n[知乎的一些讨论](http://www.zhihu.com/question/35522476)","slug":"singleton","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wway0013d6jx2xmn9a42"},{"title":"<<现代操作系统>>学习笔记之文件系统","date":"2016-02-22T09:18:15.000Z","_content":"\n### 文件系统简介\n\n#### 为什么需要文件系统\n\n1. 程序有需要存储大量信息的需求\n\n\t所有的计算机应用都需要存储和读取信息，如果将这些信息都放在地址空间中，那么信息的容量将会受到限制。\n\n2. 在程序关闭之后信息依然需要被保留\n\n\t如果将信息存储在地址空间中，如果进程结束，那么信息就会丢失。当进程被杀掉的时候，有些信息也需要被存储。\n\n3. 多个进程能同时访问信息\n\n\t如果将信息存储在地址空间，那么多个进程将无法访问这些信息。（采用进程间通信是另外一回事～～）\n\n#### 对长期存储器进行抽象\n\n通常我们用来存储这些信息的设备由磁盘，固态硬盘，光盘，磁带。在这部分内容中我们只需要将这些设备看做一个提供了读某个区块(block)和写某个区块的区块序列就行。但是如果只有读写区块的操作，那么在使用中，就会非常的不方便，需要考虑很多额外的问题，比如， 如何找到数据，如何隔离不同用户的信息，如何释放数据等等。\n\n正如操作系统将处理器抽象为进程，将主存储器抽象为地址空间，磁盘被抽象为了文件。\n进程，地址空间，文件是操作系统中非常重要的三个抽象。\n\n### 文件\n\n#### 文件命名\n\n文件名在进程创建文件时指定，在进程结束时依然存在并可以被其他进程使用，不同的操作系统对文件名的要求不同，当前所有的操作系统都允许1-8个字母构成的文件名。通常情况下，操作系统也允许文件名包含数字和特殊字符。\n\nUNIX的文件系统中区分文件名的大小写，MS-DOS不区分。Windows 95，Windows 98采用的是MS-DOS的文件系统FAT16， Windows 98引入了一种FAT16的扩展，称之为FAT32. Windows NT，Windows 2000，Windows XP，Windows Vista， Windows 7，Windows 8 依然支持FAT文件系统，同事也也引入了更先进的文件系统NTFS。\n\n很多操作系统都支持两部分的文件名，包括文件名和扩展名，通过 . 来进行分割。在 UNIX 中扩展名仅仅是为了阅读方便，在 Windows 中，扩展名被赋予了意义，可以将某个文件扩展名注册为属于某软件。\n\n#### 文件结构\n\n文件通常可以按照以下三种方式进行组织\n\n1. 字节流： UNIX Windows 采用这种方式组织文件， 在这种组织方式中， 操作系统不对文件提供额外的帮助或者阻拦， 仅仅当作一串字节序列， 提供了最大的灵活性。\n2. 记录序列： 在比较早期的主机上， 文件按照80个字符(穿孔卡为80列)或者132个字符(打印机为132列)组织成记录序列\n3. 树形结构： 这种方案可以更快的查询指定key的文件和提供下一个的操作， 在一些大型主机上使用来处理商业数据。\n\n#### 文件类型\n\n在 UNIX 和 Windows 中，文件被分为普通文件和目录。目录包含了文件系统的结构。 普通文件又分为 ASCII 文件和 二进制文件\n\n#### 文件存取\n\n早期的操作系统只提供了顺序存取， 值能从文件开始处依次读取文件， 后来的操作系统支持随机读取文件， 在 UNIX 和 Windows 中是通过 seek 来实现\n\n#### 文件属性\n\n每个文件除了由名字和数据之外， 操作系统还为文件保存了一些其他的信息， 这些额外的信息被称为文件的属性\n\n1. Protection\n\t谁可以访问此文件\n2. Password\n\t访问此文件的密码\n3. Creator\n\t文件的创建者\n4. Owner\n\t文件当前的拥有者\n5. Read-only flag\n\t0 为读写， 1 为只读\n6. Hidden flag\n\t0 为普通， 1 为隐藏\n7. Syste flag\n\t0 为普通， 1 为系统文件\n8. Archive flag\n\t0 为已经备份， 1 为需要备份\n9. ASCII/binary flag\n\t0 为 ASCII 文件， 1 为二进制问津啊\n10. Random access flag\n\t0 为只能顺序读写， 1 为可以随机访问\n11. Temporary flag\n\t0 为普通文件， 1 为临时文件， 在进程结束时删除\n12. Lock flag\n\t0 表示未加锁， 非零表示文件已加锁\n13. Record length\n\t记录中的字节数\n14. Key position\n\t每条记录的偏移\n15. Key length\n\tkey的字节数\n16. Create time\n\t文件创建的时间\n17. Time of last access\n\t文件的最后访问时间\n18. Time of last change\n\t文件的最后修改时间\n19. Current size\n\t当前文件的大小(字节数)\n20. Maximum size\n\t文件的最大大小(字节数)\n\n以上的属性并不是每个系统都全部拥有， 但是每个都出现在某一个操作系统中\n\n#### 文件的操作\n\n1. Create\n\t创建一个不含数据的文件\n2. Delete\n\t删除一个文件\n3. Open\n\t进程通过此操作打开一个文件\n4. Close\n\t进程通过此操作关闭一个文件\n5. Read\n\t从文件中读取数据，通常需要提供长度\n6. Write\n\t向文件中写入数据\n7. Append\n\t在文件结尾处添加数据， 有的操作系统不提供此操作\n8. Seek\n\t对于随机访问文件，通过此操作移动到某个位置\n9. Get attributes\n\t读取文件的属性\n10. Set attributes\n\t设置文件的树形\n11. Rename \n\t对已经存在的文件进行重命名\n\t\n","source":"_posts/modern-operating-systems-file-systems.md","raw":"title: <<现代操作系统>>学习笔记之文件系统\ndate: 2016-02-22 17:18:15\ntags: [operating system, file system, modern operating systems]\ncategories: Operating Systems\n---\n\n### 文件系统简介\n\n#### 为什么需要文件系统\n\n1. 程序有需要存储大量信息的需求\n\n\t所有的计算机应用都需要存储和读取信息，如果将这些信息都放在地址空间中，那么信息的容量将会受到限制。\n\n2. 在程序关闭之后信息依然需要被保留\n\n\t如果将信息存储在地址空间中，如果进程结束，那么信息就会丢失。当进程被杀掉的时候，有些信息也需要被存储。\n\n3. 多个进程能同时访问信息\n\n\t如果将信息存储在地址空间，那么多个进程将无法访问这些信息。（采用进程间通信是另外一回事～～）\n\n#### 对长期存储器进行抽象\n\n通常我们用来存储这些信息的设备由磁盘，固态硬盘，光盘，磁带。在这部分内容中我们只需要将这些设备看做一个提供了读某个区块(block)和写某个区块的区块序列就行。但是如果只有读写区块的操作，那么在使用中，就会非常的不方便，需要考虑很多额外的问题，比如， 如何找到数据，如何隔离不同用户的信息，如何释放数据等等。\n\n正如操作系统将处理器抽象为进程，将主存储器抽象为地址空间，磁盘被抽象为了文件。\n进程，地址空间，文件是操作系统中非常重要的三个抽象。\n\n### 文件\n\n#### 文件命名\n\n文件名在进程创建文件时指定，在进程结束时依然存在并可以被其他进程使用，不同的操作系统对文件名的要求不同，当前所有的操作系统都允许1-8个字母构成的文件名。通常情况下，操作系统也允许文件名包含数字和特殊字符。\n\nUNIX的文件系统中区分文件名的大小写，MS-DOS不区分。Windows 95，Windows 98采用的是MS-DOS的文件系统FAT16， Windows 98引入了一种FAT16的扩展，称之为FAT32. Windows NT，Windows 2000，Windows XP，Windows Vista， Windows 7，Windows 8 依然支持FAT文件系统，同事也也引入了更先进的文件系统NTFS。\n\n很多操作系统都支持两部分的文件名，包括文件名和扩展名，通过 . 来进行分割。在 UNIX 中扩展名仅仅是为了阅读方便，在 Windows 中，扩展名被赋予了意义，可以将某个文件扩展名注册为属于某软件。\n\n#### 文件结构\n\n文件通常可以按照以下三种方式进行组织\n\n1. 字节流： UNIX Windows 采用这种方式组织文件， 在这种组织方式中， 操作系统不对文件提供额外的帮助或者阻拦， 仅仅当作一串字节序列， 提供了最大的灵活性。\n2. 记录序列： 在比较早期的主机上， 文件按照80个字符(穿孔卡为80列)或者132个字符(打印机为132列)组织成记录序列\n3. 树形结构： 这种方案可以更快的查询指定key的文件和提供下一个的操作， 在一些大型主机上使用来处理商业数据。\n\n#### 文件类型\n\n在 UNIX 和 Windows 中，文件被分为普通文件和目录。目录包含了文件系统的结构。 普通文件又分为 ASCII 文件和 二进制文件\n\n#### 文件存取\n\n早期的操作系统只提供了顺序存取， 值能从文件开始处依次读取文件， 后来的操作系统支持随机读取文件， 在 UNIX 和 Windows 中是通过 seek 来实现\n\n#### 文件属性\n\n每个文件除了由名字和数据之外， 操作系统还为文件保存了一些其他的信息， 这些额外的信息被称为文件的属性\n\n1. Protection\n\t谁可以访问此文件\n2. Password\n\t访问此文件的密码\n3. Creator\n\t文件的创建者\n4. Owner\n\t文件当前的拥有者\n5. Read-only flag\n\t0 为读写， 1 为只读\n6. Hidden flag\n\t0 为普通， 1 为隐藏\n7. Syste flag\n\t0 为普通， 1 为系统文件\n8. Archive flag\n\t0 为已经备份， 1 为需要备份\n9. ASCII/binary flag\n\t0 为 ASCII 文件， 1 为二进制问津啊\n10. Random access flag\n\t0 为只能顺序读写， 1 为可以随机访问\n11. Temporary flag\n\t0 为普通文件， 1 为临时文件， 在进程结束时删除\n12. Lock flag\n\t0 表示未加锁， 非零表示文件已加锁\n13. Record length\n\t记录中的字节数\n14. Key position\n\t每条记录的偏移\n15. Key length\n\tkey的字节数\n16. Create time\n\t文件创建的时间\n17. Time of last access\n\t文件的最后访问时间\n18. Time of last change\n\t文件的最后修改时间\n19. Current size\n\t当前文件的大小(字节数)\n20. Maximum size\n\t文件的最大大小(字节数)\n\n以上的属性并不是每个系统都全部拥有， 但是每个都出现在某一个操作系统中\n\n#### 文件的操作\n\n1. Create\n\t创建一个不含数据的文件\n2. Delete\n\t删除一个文件\n3. Open\n\t进程通过此操作打开一个文件\n4. Close\n\t进程通过此操作关闭一个文件\n5. Read\n\t从文件中读取数据，通常需要提供长度\n6. Write\n\t向文件中写入数据\n7. Append\n\t在文件结尾处添加数据， 有的操作系统不提供此操作\n8. Seek\n\t对于随机访问文件，通过此操作移动到某个位置\n9. Get attributes\n\t读取文件的属性\n10. Set attributes\n\t设置文件的树形\n11. Rename \n\t对已经存在的文件进行重命名\n\t\n","slug":"modern-operating-systems-file-systems","published":1,"updated":"2016-02-29T16:42:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwb3001gd6jxiubwat4h"},{"title":"Java学习总结三 字符串","date":"2015-12-06T15:44:06.000Z","_content":"\n#### 不可变String\n\nString对象是不可改变的，String类中看起来能改变字符串内容的方法实际上都是创建了一个新的String对象，原来的对象并未发生改变,如下代码\n\n```java\npublic class TestClass {\n    public static void main(String[] args) {\n        String s1 = \"howdy\";\n        System.out.println(s1);\n        String s2 = s1.toUpperCase();\n        System.out.println(s2);\n        System.out.println(s1);\n    }\n}\n```\n输出为:\n\n\thowdy\n\tHOWDY\n\thowdy\n    \n#### StringBuilder\n\n考虑到如下代码\n```java\npublic class TestClass {\n    public static void main(String[] args) {\n        String s1 = \"yeyeyeye\";\n        String s2 = \"1\" + s1 + \"2\" + \"3\";\n    }\n}\n\n```\n我们知道，String对象是不可变的，那么从代码上来看s2的创建过程中,\"1\"+s1首先会生成一个临时对象，然后再加上“2”会在生成一个临时对象，再加上“3”会生成最后的对象把引用赋给上s2，这过程中产生的临时对下你个是会对效率产生影响的\n不过对于这种简单的语句，我们编译器是会自动采取优化的，会自动引入StringBuilder类来构造s2，这样就会省略掉这些中间对象\n对以上代码字节码进行分析  javap -c TestClass\n\n    Compiled from \"TestClass.java\"\n    public class TestClass {\n    public TestClass();\n        Code:\n        0: aload_0\n        1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n        4: return\n    \n    public static void main(java.lang.String[]);\n        Code:\n        0: ldc           #2                  // String yeyeyeye\n        2: astore_1\n        3: new           #3                  // class java/lang/StringBuilder\n        6: dup\n        7: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":()V\n        10: ldc           #5                  // String 1\n        12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        15: aload_1\n        16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        19: ldc           #7                  // String 2\n        21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        24: ldc           #8                  // String 3\n        26: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        29: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n        32: astore_2\n        33: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream;\n        36: aload_2\n        37: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        40: return\n    }\n\n    \n我们可以看到，生成的字节码中自动引入了StringBuilder类，使用它的append方法来添加新的内容，防止多次构造临时对象，再看看下面一段代码和其生成的字节码\n\n```java\npublic class TestClass {\n    public static void main(String[] args) {\n    }\n\n    public String implicit(String[] s)\n    {\n        String result = \"\";\n        for(int i=0; i< s.length; i++) {\n            result += s[i];\n        }\n        return result;\n    }\n\n    public String explicit(String[] s)\n    {\n        StringBuilder result= new StringBuilder();\n        for(int i=0; i< s.length; i++) {\n            result.append(s[i]);\n        }\n        return result.toString();\n    }\n}\n```\n\n    Compiled from \"TestClass.java\"\n    public class TestClass {\n    public TestClass();\n        Code:\n        0: aload_0\n        1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n        4: return\n    \n    public static void main(java.lang.String[]);\n        Code:\n        0: return\n    \n    public java.lang.String implicit(java.lang.String[]);\n        Code:\n        0: ldc           #2                  // String\n        2: astore_2\n        3: iconst_0\n        4: istore_3\n        5: iload_3\n        6: aload_1\n        7: arraylength\n        8: if_icmpge     38\n        11: new           #3                  // class java/lang/StringBuilder\n        14: dup\n        15: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":()V\n        18: aload_2\n        19: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        22: aload_1\n        23: iload_3\n        24: aaload\n        25: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        28: invokevirtual #6                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n        31: astore_2\n        32: iinc          3, 1\n        35: goto          5\n        38: aload_2\n        39: areturn\n    \n    public java.lang.String explicit(java.lang.String[]);\n        Code:\n        0: new           #3                  // class java/lang/StringBuilder\n        3: dup\n        4: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":()V\n        7: astore_2\n        8: iconst_0\n        9: istore_3\n        10: iload_3\n        11: aload_1\n        12: arraylength\n        13: if_icmpge     30\n        16: aload_2\n        17: aload_1\n        18: iload_3\n        19: aaload\n        20: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        23: pop\n        24: iinc          3, 1\n        27: goto          10\n        30: aload_2\n        31: invokevirtual #6                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n        34: areturn\n    }\n\n我们可以看到在implicit方法中，每次循环都会将StringBuilder变成String，在explicit方法中，最后再执行的StringBuilder到String的转换，显然显然，explicit方法效率会高很多，因此在我们使用String的时候需要注意这个问题，如果遇到循环，我们可以自己手动使用StringBuilder来优化，防止多次，无用的构造String临时对象\nStringBuilder 是Java SE5 引入的，在这之前用的是StringBuffer, 后者是线程安全的，同时开销也会大一些\n\n#### String 类提供的方法\n\n##### 构造器\n\n构造一个 String 对象\n\n```java\nString s1 = new String();\nSystem.out.println(s1);\nbyte[] bytes = { 97, 98, 99, 100, 101};\nString s2 = new String(bytes);\nSystem.out.println(s2);\nchar[] chars = {'a', 'b', 'c', 'd', 'e'};\nString s3 = new String(chars);\nSystem.out.println(s3);\nint[] codePoints = {97, 98, 99, 100, 101};\nString s4 = new String(chars);\nSystem.out.println(s4);\nStringBuilder sb = new StringBuilder();\nfor (int i=1;i<6;i++) {\n    sb.append(i);\n}\nString s5 = new String(sb);\nSystem.out.println(s5);\nStringBuffer sbuffer = new StringBuffer();\nfor (int i=6;i<11;i++) {\n    sbuffer.append(i);\n}\nString s6 = new String(sbuffer);\nSystem.out.println(s6);\n```\n\n##### length()\n\n获取 String 对象的长度\n```java\npublic int length();\n```\n\n```java\nString s1 = \"xyzwaaa\";\nSystem.out.println(s1.length()); // 将会输出 7\n```\n\n##### charAt()\n\n获取指定位置的char\n```java\npublic char charAt(int index);\n```\n\n```java\nString s = \"ABCDEFGHIJKLM\";\nchar ch = s.charAt(4);  //char 为 'E'\n```\n\n##### getChars(), getBytes()\n\n复制chars或者bytes到一个数组\n\n```java\npublic void getChars(int srcBegin, int srcEnd, char[] dst, int destBegin);\npublic void getBytes(int srcBegin, int srcEnd, byte[] dst, int destBegin); \n```\n\n```java\nString s = \"ABCDEFGHIJKLM\";\nchar[] dest1 =new char[10];\ns.getChars(0,5,dest1,0);  //dest1: {A, B, C, D, E, , , , ,}\nbyte[] dest2 = new byte[10];\ns.getBytes(5,10,dest2,5); //dest2: {0, 0, 0, 0, 0, 70, 71, 72, 73, 74}\n```\n\n##### toCharArray()\n\n转换为一个char[]的数组\n\n```java\npublic char[] toCharArray()\n```\n\n```java\nString s= \"ABCDEF\";\nchar[] chars = s.toCharArray(); // CHARS: {A, B, C, D, E, F}\n```\n\n##### equals(), equalsIgnoreCase()\n\n检测是否相等(内容而不是引用)\n\n```java\nboolean equals(Object anObject); //比较和另外一个对象是否相 当且仅当参数不为null且为一个序列相等的String对象的时候返回true\nboolean equalsIgnoreCase(String anotherString); //比较和另外一个string是否相等，忽略大小写\n```\n\n```java\nchar[] chars = {'A', 'b', 'C', 'd'};\nString s1 = new String(chars);\nString s2 = new String(chars);\nString s3 = \"ABCD\";\nSystem.out.println(s1 == s2); //false\nSystem.out.println(s1.equals(s2));  // true\nSystem.out.println(s1.equals(chars)); //false\nSystem.out.println(s1.equals(s3)); //false\nSystem.out.println(s1.equalsIgnoreCase(s3)); //true\n```\n\n##### compareTo(), compareToIgnoreCase()\n\n与另外String进行比较，返回-1,0,1\n\n```java\npublic int compareTo(String anotherString)\npublic int compareToIgnoreCase(String anotherString)\n```\n\n```java\nString s1 = \"abcde\";\nString s2 = \"abcde\";\nString s3 = \"bbcde\";\nSystem.out.println(s1.compareTo(s2)); //  0\nSystem.out.println(s1.compareTo(s3)); // -1\nSystem.out.println(s3.compareTo(s1)); // 1\n```\n\n#### 更多方法， 参考[String](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html)\n\n[oracle String 文档](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html)\n\n#### 格式化输出\n\n##### printf()\n\nJava也支持同C类似的printf\n\n```java\nSystem.out.printf(\"%d,%d,%c\", 10,20,'A');\n```\n\n##### format()\n\nfromat 和 printf是等价的，作用于PringStream或PrintWritter对象\n\n```java\nSystem.out.format(\"%d,%d,%c\", 10,20,'A');\n```\n\n##### Formatter类\n\n新的格式化功能由java.util.Formatter类处理。\n\n```java\npublic static void main(String[] args) {\n    Formatter f = new Formatter(System.out);\n    String name = \"xiejun\";\n    int age = 25;\n    f.format(\"name:%s, age: %d\",name, age);\n}\n```\n\n##### 格式化说明符\n\n其语法如下:\n\n    %[argument_index$][flags][width][.precision]conversion\n    \n```java\npublic static void main(String[] args) {\n    Formatter f = new Formatter(System.out);\n    String name = \"xiejun\";\n    int age = 25;\n    double height = 1.75;\n    f.format(\"name:%-15s, age: %5d, age: %7f\\n\",name, age, height);\n    f.format(\"name:%15s, age: %5d, age: %7f\\n\",name, age, height);\n    f.format(\"name:%2.2s, age: %5d, age: %1.4f\\n\",name, age, height);\n}\n```\n\n    name:xiejun         , age:    25, age: 1.750000\n    name:         xiejun, age:    25, age: 1.750000\n    name:     xi, age:    25, age: 1.7500\n\nwidth 应用于各种类型表示数据最小尺寸， precision用于控制最大尺寸，应用于String时，表示打印出的最大字符量，对浮点数时，表示小数部分要显示出来的位数，对整数使用则会触发异常\n\n|      |   |\n| ----  | --- |\n| %d  |  十进制整形数字 |\n| %c  |  Unicode字符|\n|%b  | boolean值|\n|%s |String|\n|%f | 浮点，十进制|\n|%e  |浮点，科学计数|\n|%x|整数，十六进制|\n|%h|hash code，十六进制|\n|%%|字符%|\n\n##### String.format()\n\n类似于C中的sprintf，String.format() 接受与Formatter.fromat()相同的参数，但是返回一个String对象\n\n#### 正则表达式\n\n 正则表达式是一种很强大的文本处理工具，通过正则表示我们可以很方便的通过编程来处理字符串的模式匹配问题\n \n ##### 基础\n \n 通过String.matches来使用正则表达式\n \n ```java\n public boolean matches(String regex)\n ```\n \n ```java\n    public static void main(String[] args) {\n    System.out.println(\"-12345\".matches(\"-?\\\\d+\")); //true\n    System.out.println(\"5678\".matches(\"-?\\\\d+\")); //true\n    System.out.println(\"+91011\".matches(\"-?\\\\d+\")); //false\n    System.out.println(\"+911\".matches(\"(-|\\\\+)?\\\\d+\")); //true\n}\n ```\n \n    ? ：代表出现一次或多次\n    + ：代表出现一次或者多次\n    | ：代表并联\n    \\\\ : 表示开始一个转义字符\n    \n通过String.split()方法也能使用正则表达式\n\n```java\npublic String[] split(String regex, int limit)\n```\n\n```java\nString s1 = \"abcd,efgh;mnky!dsdy\";\nString[] ss = s1.split(\",|;|!\"); // : {abcd, efgh, mnky, dsdy}\n```\n\n##### 创建正则表达式\n\n  更多正则表达式相关内容后面再补充吧","source":"_posts/java-string.md","raw":"title: Java学习总结三 字符串\ndate: 2015-12-6 23:44:06\ntags: [string, java]\n---\n\n#### 不可变String\n\nString对象是不可改变的，String类中看起来能改变字符串内容的方法实际上都是创建了一个新的String对象，原来的对象并未发生改变,如下代码\n\n```java\npublic class TestClass {\n    public static void main(String[] args) {\n        String s1 = \"howdy\";\n        System.out.println(s1);\n        String s2 = s1.toUpperCase();\n        System.out.println(s2);\n        System.out.println(s1);\n    }\n}\n```\n输出为:\n\n\thowdy\n\tHOWDY\n\thowdy\n    \n#### StringBuilder\n\n考虑到如下代码\n```java\npublic class TestClass {\n    public static void main(String[] args) {\n        String s1 = \"yeyeyeye\";\n        String s2 = \"1\" + s1 + \"2\" + \"3\";\n    }\n}\n\n```\n我们知道，String对象是不可变的，那么从代码上来看s2的创建过程中,\"1\"+s1首先会生成一个临时对象，然后再加上“2”会在生成一个临时对象，再加上“3”会生成最后的对象把引用赋给上s2，这过程中产生的临时对下你个是会对效率产生影响的\n不过对于这种简单的语句，我们编译器是会自动采取优化的，会自动引入StringBuilder类来构造s2，这样就会省略掉这些中间对象\n对以上代码字节码进行分析  javap -c TestClass\n\n    Compiled from \"TestClass.java\"\n    public class TestClass {\n    public TestClass();\n        Code:\n        0: aload_0\n        1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n        4: return\n    \n    public static void main(java.lang.String[]);\n        Code:\n        0: ldc           #2                  // String yeyeyeye\n        2: astore_1\n        3: new           #3                  // class java/lang/StringBuilder\n        6: dup\n        7: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":()V\n        10: ldc           #5                  // String 1\n        12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        15: aload_1\n        16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        19: ldc           #7                  // String 2\n        21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        24: ldc           #8                  // String 3\n        26: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        29: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n        32: astore_2\n        33: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream;\n        36: aload_2\n        37: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        40: return\n    }\n\n    \n我们可以看到，生成的字节码中自动引入了StringBuilder类，使用它的append方法来添加新的内容，防止多次构造临时对象，再看看下面一段代码和其生成的字节码\n\n```java\npublic class TestClass {\n    public static void main(String[] args) {\n    }\n\n    public String implicit(String[] s)\n    {\n        String result = \"\";\n        for(int i=0; i< s.length; i++) {\n            result += s[i];\n        }\n        return result;\n    }\n\n    public String explicit(String[] s)\n    {\n        StringBuilder result= new StringBuilder();\n        for(int i=0; i< s.length; i++) {\n            result.append(s[i]);\n        }\n        return result.toString();\n    }\n}\n```\n\n    Compiled from \"TestClass.java\"\n    public class TestClass {\n    public TestClass();\n        Code:\n        0: aload_0\n        1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n        4: return\n    \n    public static void main(java.lang.String[]);\n        Code:\n        0: return\n    \n    public java.lang.String implicit(java.lang.String[]);\n        Code:\n        0: ldc           #2                  // String\n        2: astore_2\n        3: iconst_0\n        4: istore_3\n        5: iload_3\n        6: aload_1\n        7: arraylength\n        8: if_icmpge     38\n        11: new           #3                  // class java/lang/StringBuilder\n        14: dup\n        15: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":()V\n        18: aload_2\n        19: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        22: aload_1\n        23: iload_3\n        24: aaload\n        25: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        28: invokevirtual #6                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n        31: astore_2\n        32: iinc          3, 1\n        35: goto          5\n        38: aload_2\n        39: areturn\n    \n    public java.lang.String explicit(java.lang.String[]);\n        Code:\n        0: new           #3                  // class java/lang/StringBuilder\n        3: dup\n        4: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":()V\n        7: astore_2\n        8: iconst_0\n        9: istore_3\n        10: iload_3\n        11: aload_1\n        12: arraylength\n        13: if_icmpge     30\n        16: aload_2\n        17: aload_1\n        18: iload_3\n        19: aaload\n        20: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n        23: pop\n        24: iinc          3, 1\n        27: goto          10\n        30: aload_2\n        31: invokevirtual #6                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n        34: areturn\n    }\n\n我们可以看到在implicit方法中，每次循环都会将StringBuilder变成String，在explicit方法中，最后再执行的StringBuilder到String的转换，显然显然，explicit方法效率会高很多，因此在我们使用String的时候需要注意这个问题，如果遇到循环，我们可以自己手动使用StringBuilder来优化，防止多次，无用的构造String临时对象\nStringBuilder 是Java SE5 引入的，在这之前用的是StringBuffer, 后者是线程安全的，同时开销也会大一些\n\n#### String 类提供的方法\n\n##### 构造器\n\n构造一个 String 对象\n\n```java\nString s1 = new String();\nSystem.out.println(s1);\nbyte[] bytes = { 97, 98, 99, 100, 101};\nString s2 = new String(bytes);\nSystem.out.println(s2);\nchar[] chars = {'a', 'b', 'c', 'd', 'e'};\nString s3 = new String(chars);\nSystem.out.println(s3);\nint[] codePoints = {97, 98, 99, 100, 101};\nString s4 = new String(chars);\nSystem.out.println(s4);\nStringBuilder sb = new StringBuilder();\nfor (int i=1;i<6;i++) {\n    sb.append(i);\n}\nString s5 = new String(sb);\nSystem.out.println(s5);\nStringBuffer sbuffer = new StringBuffer();\nfor (int i=6;i<11;i++) {\n    sbuffer.append(i);\n}\nString s6 = new String(sbuffer);\nSystem.out.println(s6);\n```\n\n##### length()\n\n获取 String 对象的长度\n```java\npublic int length();\n```\n\n```java\nString s1 = \"xyzwaaa\";\nSystem.out.println(s1.length()); // 将会输出 7\n```\n\n##### charAt()\n\n获取指定位置的char\n```java\npublic char charAt(int index);\n```\n\n```java\nString s = \"ABCDEFGHIJKLM\";\nchar ch = s.charAt(4);  //char 为 'E'\n```\n\n##### getChars(), getBytes()\n\n复制chars或者bytes到一个数组\n\n```java\npublic void getChars(int srcBegin, int srcEnd, char[] dst, int destBegin);\npublic void getBytes(int srcBegin, int srcEnd, byte[] dst, int destBegin); \n```\n\n```java\nString s = \"ABCDEFGHIJKLM\";\nchar[] dest1 =new char[10];\ns.getChars(0,5,dest1,0);  //dest1: {A, B, C, D, E, , , , ,}\nbyte[] dest2 = new byte[10];\ns.getBytes(5,10,dest2,5); //dest2: {0, 0, 0, 0, 0, 70, 71, 72, 73, 74}\n```\n\n##### toCharArray()\n\n转换为一个char[]的数组\n\n```java\npublic char[] toCharArray()\n```\n\n```java\nString s= \"ABCDEF\";\nchar[] chars = s.toCharArray(); // CHARS: {A, B, C, D, E, F}\n```\n\n##### equals(), equalsIgnoreCase()\n\n检测是否相等(内容而不是引用)\n\n```java\nboolean equals(Object anObject); //比较和另外一个对象是否相 当且仅当参数不为null且为一个序列相等的String对象的时候返回true\nboolean equalsIgnoreCase(String anotherString); //比较和另外一个string是否相等，忽略大小写\n```\n\n```java\nchar[] chars = {'A', 'b', 'C', 'd'};\nString s1 = new String(chars);\nString s2 = new String(chars);\nString s3 = \"ABCD\";\nSystem.out.println(s1 == s2); //false\nSystem.out.println(s1.equals(s2));  // true\nSystem.out.println(s1.equals(chars)); //false\nSystem.out.println(s1.equals(s3)); //false\nSystem.out.println(s1.equalsIgnoreCase(s3)); //true\n```\n\n##### compareTo(), compareToIgnoreCase()\n\n与另外String进行比较，返回-1,0,1\n\n```java\npublic int compareTo(String anotherString)\npublic int compareToIgnoreCase(String anotherString)\n```\n\n```java\nString s1 = \"abcde\";\nString s2 = \"abcde\";\nString s3 = \"bbcde\";\nSystem.out.println(s1.compareTo(s2)); //  0\nSystem.out.println(s1.compareTo(s3)); // -1\nSystem.out.println(s3.compareTo(s1)); // 1\n```\n\n#### 更多方法， 参考[String](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html)\n\n[oracle String 文档](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html)\n\n#### 格式化输出\n\n##### printf()\n\nJava也支持同C类似的printf\n\n```java\nSystem.out.printf(\"%d,%d,%c\", 10,20,'A');\n```\n\n##### format()\n\nfromat 和 printf是等价的，作用于PringStream或PrintWritter对象\n\n```java\nSystem.out.format(\"%d,%d,%c\", 10,20,'A');\n```\n\n##### Formatter类\n\n新的格式化功能由java.util.Formatter类处理。\n\n```java\npublic static void main(String[] args) {\n    Formatter f = new Formatter(System.out);\n    String name = \"xiejun\";\n    int age = 25;\n    f.format(\"name:%s, age: %d\",name, age);\n}\n```\n\n##### 格式化说明符\n\n其语法如下:\n\n    %[argument_index$][flags][width][.precision]conversion\n    \n```java\npublic static void main(String[] args) {\n    Formatter f = new Formatter(System.out);\n    String name = \"xiejun\";\n    int age = 25;\n    double height = 1.75;\n    f.format(\"name:%-15s, age: %5d, age: %7f\\n\",name, age, height);\n    f.format(\"name:%15s, age: %5d, age: %7f\\n\",name, age, height);\n    f.format(\"name:%2.2s, age: %5d, age: %1.4f\\n\",name, age, height);\n}\n```\n\n    name:xiejun         , age:    25, age: 1.750000\n    name:         xiejun, age:    25, age: 1.750000\n    name:     xi, age:    25, age: 1.7500\n\nwidth 应用于各种类型表示数据最小尺寸， precision用于控制最大尺寸，应用于String时，表示打印出的最大字符量，对浮点数时，表示小数部分要显示出来的位数，对整数使用则会触发异常\n\n|      |   |\n| ----  | --- |\n| %d  |  十进制整形数字 |\n| %c  |  Unicode字符|\n|%b  | boolean值|\n|%s |String|\n|%f | 浮点，十进制|\n|%e  |浮点，科学计数|\n|%x|整数，十六进制|\n|%h|hash code，十六进制|\n|%%|字符%|\n\n##### String.format()\n\n类似于C中的sprintf，String.format() 接受与Formatter.fromat()相同的参数，但是返回一个String对象\n\n#### 正则表达式\n\n 正则表达式是一种很强大的文本处理工具，通过正则表示我们可以很方便的通过编程来处理字符串的模式匹配问题\n \n ##### 基础\n \n 通过String.matches来使用正则表达式\n \n ```java\n public boolean matches(String regex)\n ```\n \n ```java\n    public static void main(String[] args) {\n    System.out.println(\"-12345\".matches(\"-?\\\\d+\")); //true\n    System.out.println(\"5678\".matches(\"-?\\\\d+\")); //true\n    System.out.println(\"+91011\".matches(\"-?\\\\d+\")); //false\n    System.out.println(\"+911\".matches(\"(-|\\\\+)?\\\\d+\")); //true\n}\n ```\n \n    ? ：代表出现一次或多次\n    + ：代表出现一次或者多次\n    | ：代表并联\n    \\\\ : 表示开始一个转义字符\n    \n通过String.split()方法也能使用正则表达式\n\n```java\npublic String[] split(String regex, int limit)\n```\n\n```java\nString s1 = \"abcd,efgh;mnky!dsdy\";\nString[] ss = s1.split(\",|;|!\"); // : {abcd, efgh, mnky, dsdy}\n```\n\n##### 创建正则表达式\n\n  更多正则表达式相关内容后面再补充吧","slug":"java-string","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwb9001pd6jx9gggd292"},{"title":"Java 学习总结一 多态","date":"2015-12-01T13:36:07.000Z","_content":"\n## 多态\n\n### 多态\n\n多态(polymorphism)是面向对象的核心思想之一，多态就是说在调用类的方法的时候，由运行时的类型来决定调用的是哪个方法，也可称作后期绑定，动态绑定。\n在java中，除了 static 和 final 修饰的方法都是动态绑定的(等同于C++中使用virtual修饰)，可以很方便的实现多态.\n通过多态，我们可以将做什么和怎么做进行解耦，使得代码的扩展能力更强\n如以下的代码，我们可以看到TestClass中的draw函数接受了一个Shape类型的引用，在实际运行时，只要是Shape的派生类都能通过参数传递，然后调用时会根据s 的类型来决定是调用Circle的draw方法还是Square的draw方法\n如果我们新增了一个类Rectangle继承于Shape,那么draw函数是不需要做更改就能处理Rectangle这个类的\n\n```java\npublic class Shape {\n    public void draw(){\n        System.out.println(\"drawing an shape\");\n    }\n}\n\npublic class Circle extends Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"drawing a circle\");\n    }\n}\n\npublic class Square extends Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"drawing an square\");\n    }\n}\n\npublic class TestClass {\n    public static void main(String[] args) {\n        Shape s1 = new Square();\n        Shape s2 = new Circle();\n        draw(s1);\n        draw(s2);\n    }\n\n    public static void draw(Shape s) {\n        s.draw();\n    }\n}\n\n```\n\n### 不要覆盖私有方法\n\n由于对于继承，如果基类中的方法定义为private， 那么会被自动认为是final的，并且对导出类是不可见的，也就是说如果在导出类中写了同样的方法，那么将是一个全新的方法，并不是对基类的覆盖\n\n```java\npublic class PrivateOverride {\n    private void fun() {\n        System.out.println(\"private fun() in PrivateOveride\");\n    }\n    public static void main(String[] args) {\n        PrivateOverride po = new Derived();\n        po.fun();\n    }\n}\n\nclass Derived extends PrivateOverride{\n    public void fun() {\n        System.out.println(\"public fun() in Derived\");\n    }\n}\n```\n对于以上代码，会输出\n\n    private fun() in PrivateOveride\n\n基类中的方法并没有被覆盖，调用时前期绑定，直接调用了PrivateOverride类中的fun方法\n\n### 不要覆盖域和静态方法\n\n与上面提到的一样，对于域和静态方法，也是不具有多态性的，要想拿到父类的域或者方法可以通过 super 来调用\n\n### 向下转型与运行时类型识别\n\n在进行向上转型时候，由于基类不会具有大于导出类的接口，因此向上转型是安全的，如果我们要进行向下转型，那么如果类的运行时类型是Circle，我们想要将它转型成一个Square，显然是不合理的，在Java中，我们所有的转型都会进行类型检查，因此当我们进行向下转型的时候，如果类型是不符的，将会抛出一个ClassCastException\n在运行期间对类型进行检查的行为称作“运行时类型识别”（RTTI， Run Time Type Identification ）\n\n```java\npublic class TestClass {\n    public static void main(String[] args) {\n        Shape s1 = new Square();\n        Square s2 = (Square) s1;\n        Circle s3 = (Circle) s1;\n    }\n\n}\n\n```\n在运行以上代码的时候我们可以发现 Circle s3 = (Circle) s1; 这一句会抛出异常\n\n    Exception in thread \"main\" java.lang.ClassCastException: shape.Square cannot be cast to shape.Circle\n\tat TestClass.main(TestClass.java:12)\n    \n\n## 接口\n\n接口是用来将实现和接口进行分离的方法，在Jva中，从语言层面对接口进行了支持\n\n### 抽象类\n\n抽象类是在普通类和接口之间的一种中庸之道， 在很多的继承体系中，基类中的方法往往是不需要被实现的，只是为了为为其导出的类提供一个统一的接口，此时我们可以将方法申明为抽象方法，通过以下方式来进行申明\n\n```java\nabstract void f();\n```\n\n包含了抽象方法的类就被成为抽象类。如果一个类包含了一个或多个抽象方法，那么此类必须被限定为抽象类，对于抽象类，我们无法从该类实例化一个对象\n\n```java\npublic abstract class Instrument {\n    public abstract void play();\n}\n\npublic class Wind extends Instrument{\n    public void play() {\n        System.out.println(\"Wind play\");\n    }\n}\n\npublic class Percussion extends Instrument{\n    public void play() {\n        System.out.println(\"Percussion play\");\n    }\n}\n\n```\n\n当我们试图实例化一个抽象类的时候，编译器会报错\n```java\n\npublic class TestAbstractClass {\n    public static void main(String[] args) {\n       Instrument ins = new Instrument();\n       }\n    }\n}\n\n```\n以上代码是无法通过编译的\n\n### 接口\n\n在 java 中， 通过 interface 关键字来支持接口。通过接口，进行了更为高级的抽象。接口产生了一个完全抽象的类，在类中确定了方法名，参数列表和返回类型，但是没有任何实体，接口用来建立类与类之间的协议\n通过以下代码来创建一个接口\n```java\ninterface  Instrument {\n    void play();\n    void what();\n    void adjust();\n}\n```\n我们可以看到，方法的申明和接口的申明并未用public修饰，因为对于接口而言，不加public表示接口和方法默认是public的，此时在试验一个接口的时候，就需要将方法定义为public的，否则的话会导致访问权限被降低，这在java中是不允许的\n```java\nclass Wind implements Instrument {\n    private void play(){}\n    private void what(){}\n    private void adjust(){}\n}\n```\n\n    Error:(7, 18) java: interface_sample.Wind中的play()无法实现interface_sample.Instrument中的play()\n    正在尝试分配更低的访问权限; 以前为public\n    \n我们可以看到以上代码是无法通过编译的，需要将方法申明为public\n\n我们可以发现，在使用的时候，接口和抽象类是类似的，都可以利用他们的向上转型来实现多态，可以通过接口或者抽象类或者普通的基类来将一组不同类型的对象组织在容器里，使用的时候并没有什么区别\n从语言层面上来看，我们可以对接口和抽象类做以下对比\n\n| 参数\t| 抽象类\t| 接口 |\n| ----    | ------  | ---- |\n|默认的方法实现\t| 它可以有默认的方法实现\t| 接口完全是抽象的。它根本不存在方法的实现|\n|实现\t|子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。\t|子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现|\n|构造器|\t抽象类可以有构造器|\t接口不能有构造器|\n|与正常Java类的区别\t|除了你不能实例化抽象类之外，它和普通Java类没有任何区别\t|接口是完全不同的类型|\n|访问修饰符\t|抽象方法可以有public、protected和default这些修饰符\t|接口方法默认修饰符是public。你不可以使用其它修饰符。|\n|main方法\t|抽象方法可以有main方法并且我们可以运行它\t|接口没有main方法，因此我们不能运行它。|\n|多继承\t|抽象方法可以继承一个类和实现多个接口\t|接口只可以继承一个或多个其它接口|\n|速度\t|它比接口速度要快\t|接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。|\n|添加新方法|\t如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。\t|如果你往接口中添加方法，那么你必须改变实现该接口的类。|\n\n不过从语法上来看，这些区别除了多继承外，其实差别并不算大，接口和抽象类的主要区别还是在设计上面\n对于抽象类，我们强调的是它是由一组类的公共部分抽象而来，是满足is a 这种原则的, 比如对于汽车，马车，飞机  它们都是交通工具，因此我们可以抽象出一个交通工具的类出来，汽车 is a 交通工具, 马车 is a 交通工具\n而对于接口呢，我们强调的是遵循的一个公共接口，比如说对于汽车, 轮船，飞机，他们都能用来装人，那么我们可以抽象出一个装人的接口出来(初略理解)\n举个简单的例子，以前看algorithm4的时候还不懂java，所以基本只看算法了，对于代码都是略过的，里面提到过一点接口的内容，如以下代码，sort接收一组Comparable[]:\n\n```java\npublic class Quick{\n    public static void sort(Comparable[] a)\n    {\n    }\n}\n\npublic class Test{\n    public static void main(Sting[] agrs) {\n        Quick quick = new Quick();\n        SomeClass[] objs = new SomeClass[100]; \n        quick.sort(objs);\n    }\n}\n```\n在这个代码中，Comparable就是一种接口，这种接口的实现都实现了less这个方法，因此可以用来比较大小，在调用的时候就可以将一组对象传入sort这个方法中，在这儿并不强调SomeClass is a Comparable\n\n### Java 中的多重继承\n\n从语言上来讲，Java 并不支持 public class Derive extends Base1, base2 {} ,但是却可以实现多个接口的，因此可以靠接口来完成多重继承这个概念，如以下代码\n\n```java\n\npublic interface CanFight {\n    void fight();\n}\n\npublic interface CanFly {\n    void fly();\n}\n\npublic interface CanSwim {\n    void swim();\n}\n\npublic class AcationCharater {\n    public void fight(){}\n}\n\npublic class Hero extends AcationCharater\nimplements CanFight, CanSwim, CanFly{\n    public void fly() {}\n    public void swim() {}\n}\n``` \n\n值得注意的是，Hero从AcationCharater继承而来的fight方法也成为了接口的实现，编译器并未因为写 Hero 类时并未给出fight方法而报错\n\n就thinging in java 推荐来看，如果我们要创建不带任何方法定义和成员变量的基类，我们应该选用接口，或者说是在我们知道某事物会成为一个基类，第一选择应该是让它成为一个接口\n\n### 通过继承来扩展接口 \n\n通过继承，可以很容易的在接口中添加新的方法，因为接口支持多继承，因此可以通过接口来组合多个接口\n\n    [修饰符] interface 接口名 [extends 父接口1, 父接口2 ... ] {\n        \n    }\n    \n    \n### 适配接口\n\n同一个接口，可以允许有多个不同的实现，其中一个体现就是一个接收接口类型的方法，该接口的实现和向该方法传递的对象取决于方法的使用者。\n\n一个常见常见的用法就是策略模式，我们编写一个执行某些操作的方法，该方法接收一个我们指定的接口。使用者只需要实现这个接口，那么就可以使用这个方法，通过这种原则，可以使得方法更加灵活，通用和更强的可复用性\n\n举个简单的例子，还是用排序算法来举例,只要使用者的类实现了Comparable，那么久可以将sort作用于它\n\n```java\npublic class Quick{\n    public static void sort(Comparable[] a)\n    {\n        //will call a.less()\n    }\n}\n\npublic interface Comparable {\n    bool less();\n}\n```\n\n### 接口中的域\n\n值得注意的是，接口中的域都是 static 和 final的，可以被非常量表达式初始化\n","source":"_posts/java-polymorphism.md","raw":"title: Java 学习总结一 多态\ndate: 2015-12-01 21:36:07\ntags: [多态, 抽象类, 接口]\n---\n\n## 多态\n\n### 多态\n\n多态(polymorphism)是面向对象的核心思想之一，多态就是说在调用类的方法的时候，由运行时的类型来决定调用的是哪个方法，也可称作后期绑定，动态绑定。\n在java中，除了 static 和 final 修饰的方法都是动态绑定的(等同于C++中使用virtual修饰)，可以很方便的实现多态.\n通过多态，我们可以将做什么和怎么做进行解耦，使得代码的扩展能力更强\n如以下的代码，我们可以看到TestClass中的draw函数接受了一个Shape类型的引用，在实际运行时，只要是Shape的派生类都能通过参数传递，然后调用时会根据s 的类型来决定是调用Circle的draw方法还是Square的draw方法\n如果我们新增了一个类Rectangle继承于Shape,那么draw函数是不需要做更改就能处理Rectangle这个类的\n\n```java\npublic class Shape {\n    public void draw(){\n        System.out.println(\"drawing an shape\");\n    }\n}\n\npublic class Circle extends Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"drawing a circle\");\n    }\n}\n\npublic class Square extends Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"drawing an square\");\n    }\n}\n\npublic class TestClass {\n    public static void main(String[] args) {\n        Shape s1 = new Square();\n        Shape s2 = new Circle();\n        draw(s1);\n        draw(s2);\n    }\n\n    public static void draw(Shape s) {\n        s.draw();\n    }\n}\n\n```\n\n### 不要覆盖私有方法\n\n由于对于继承，如果基类中的方法定义为private， 那么会被自动认为是final的，并且对导出类是不可见的，也就是说如果在导出类中写了同样的方法，那么将是一个全新的方法，并不是对基类的覆盖\n\n```java\npublic class PrivateOverride {\n    private void fun() {\n        System.out.println(\"private fun() in PrivateOveride\");\n    }\n    public static void main(String[] args) {\n        PrivateOverride po = new Derived();\n        po.fun();\n    }\n}\n\nclass Derived extends PrivateOverride{\n    public void fun() {\n        System.out.println(\"public fun() in Derived\");\n    }\n}\n```\n对于以上代码，会输出\n\n    private fun() in PrivateOveride\n\n基类中的方法并没有被覆盖，调用时前期绑定，直接调用了PrivateOverride类中的fun方法\n\n### 不要覆盖域和静态方法\n\n与上面提到的一样，对于域和静态方法，也是不具有多态性的，要想拿到父类的域或者方法可以通过 super 来调用\n\n### 向下转型与运行时类型识别\n\n在进行向上转型时候，由于基类不会具有大于导出类的接口，因此向上转型是安全的，如果我们要进行向下转型，那么如果类的运行时类型是Circle，我们想要将它转型成一个Square，显然是不合理的，在Java中，我们所有的转型都会进行类型检查，因此当我们进行向下转型的时候，如果类型是不符的，将会抛出一个ClassCastException\n在运行期间对类型进行检查的行为称作“运行时类型识别”（RTTI， Run Time Type Identification ）\n\n```java\npublic class TestClass {\n    public static void main(String[] args) {\n        Shape s1 = new Square();\n        Square s2 = (Square) s1;\n        Circle s3 = (Circle) s1;\n    }\n\n}\n\n```\n在运行以上代码的时候我们可以发现 Circle s3 = (Circle) s1; 这一句会抛出异常\n\n    Exception in thread \"main\" java.lang.ClassCastException: shape.Square cannot be cast to shape.Circle\n\tat TestClass.main(TestClass.java:12)\n    \n\n## 接口\n\n接口是用来将实现和接口进行分离的方法，在Jva中，从语言层面对接口进行了支持\n\n### 抽象类\n\n抽象类是在普通类和接口之间的一种中庸之道， 在很多的继承体系中，基类中的方法往往是不需要被实现的，只是为了为为其导出的类提供一个统一的接口，此时我们可以将方法申明为抽象方法，通过以下方式来进行申明\n\n```java\nabstract void f();\n```\n\n包含了抽象方法的类就被成为抽象类。如果一个类包含了一个或多个抽象方法，那么此类必须被限定为抽象类，对于抽象类，我们无法从该类实例化一个对象\n\n```java\npublic abstract class Instrument {\n    public abstract void play();\n}\n\npublic class Wind extends Instrument{\n    public void play() {\n        System.out.println(\"Wind play\");\n    }\n}\n\npublic class Percussion extends Instrument{\n    public void play() {\n        System.out.println(\"Percussion play\");\n    }\n}\n\n```\n\n当我们试图实例化一个抽象类的时候，编译器会报错\n```java\n\npublic class TestAbstractClass {\n    public static void main(String[] args) {\n       Instrument ins = new Instrument();\n       }\n    }\n}\n\n```\n以上代码是无法通过编译的\n\n### 接口\n\n在 java 中， 通过 interface 关键字来支持接口。通过接口，进行了更为高级的抽象。接口产生了一个完全抽象的类，在类中确定了方法名，参数列表和返回类型，但是没有任何实体，接口用来建立类与类之间的协议\n通过以下代码来创建一个接口\n```java\ninterface  Instrument {\n    void play();\n    void what();\n    void adjust();\n}\n```\n我们可以看到，方法的申明和接口的申明并未用public修饰，因为对于接口而言，不加public表示接口和方法默认是public的，此时在试验一个接口的时候，就需要将方法定义为public的，否则的话会导致访问权限被降低，这在java中是不允许的\n```java\nclass Wind implements Instrument {\n    private void play(){}\n    private void what(){}\n    private void adjust(){}\n}\n```\n\n    Error:(7, 18) java: interface_sample.Wind中的play()无法实现interface_sample.Instrument中的play()\n    正在尝试分配更低的访问权限; 以前为public\n    \n我们可以看到以上代码是无法通过编译的，需要将方法申明为public\n\n我们可以发现，在使用的时候，接口和抽象类是类似的，都可以利用他们的向上转型来实现多态，可以通过接口或者抽象类或者普通的基类来将一组不同类型的对象组织在容器里，使用的时候并没有什么区别\n从语言层面上来看，我们可以对接口和抽象类做以下对比\n\n| 参数\t| 抽象类\t| 接口 |\n| ----    | ------  | ---- |\n|默认的方法实现\t| 它可以有默认的方法实现\t| 接口完全是抽象的。它根本不存在方法的实现|\n|实现\t|子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。\t|子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现|\n|构造器|\t抽象类可以有构造器|\t接口不能有构造器|\n|与正常Java类的区别\t|除了你不能实例化抽象类之外，它和普通Java类没有任何区别\t|接口是完全不同的类型|\n|访问修饰符\t|抽象方法可以有public、protected和default这些修饰符\t|接口方法默认修饰符是public。你不可以使用其它修饰符。|\n|main方法\t|抽象方法可以有main方法并且我们可以运行它\t|接口没有main方法，因此我们不能运行它。|\n|多继承\t|抽象方法可以继承一个类和实现多个接口\t|接口只可以继承一个或多个其它接口|\n|速度\t|它比接口速度要快\t|接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。|\n|添加新方法|\t如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。\t|如果你往接口中添加方法，那么你必须改变实现该接口的类。|\n\n不过从语法上来看，这些区别除了多继承外，其实差别并不算大，接口和抽象类的主要区别还是在设计上面\n对于抽象类，我们强调的是它是由一组类的公共部分抽象而来，是满足is a 这种原则的, 比如对于汽车，马车，飞机  它们都是交通工具，因此我们可以抽象出一个交通工具的类出来，汽车 is a 交通工具, 马车 is a 交通工具\n而对于接口呢，我们强调的是遵循的一个公共接口，比如说对于汽车, 轮船，飞机，他们都能用来装人，那么我们可以抽象出一个装人的接口出来(初略理解)\n举个简单的例子，以前看algorithm4的时候还不懂java，所以基本只看算法了，对于代码都是略过的，里面提到过一点接口的内容，如以下代码，sort接收一组Comparable[]:\n\n```java\npublic class Quick{\n    public static void sort(Comparable[] a)\n    {\n    }\n}\n\npublic class Test{\n    public static void main(Sting[] agrs) {\n        Quick quick = new Quick();\n        SomeClass[] objs = new SomeClass[100]; \n        quick.sort(objs);\n    }\n}\n```\n在这个代码中，Comparable就是一种接口，这种接口的实现都实现了less这个方法，因此可以用来比较大小，在调用的时候就可以将一组对象传入sort这个方法中，在这儿并不强调SomeClass is a Comparable\n\n### Java 中的多重继承\n\n从语言上来讲，Java 并不支持 public class Derive extends Base1, base2 {} ,但是却可以实现多个接口的，因此可以靠接口来完成多重继承这个概念，如以下代码\n\n```java\n\npublic interface CanFight {\n    void fight();\n}\n\npublic interface CanFly {\n    void fly();\n}\n\npublic interface CanSwim {\n    void swim();\n}\n\npublic class AcationCharater {\n    public void fight(){}\n}\n\npublic class Hero extends AcationCharater\nimplements CanFight, CanSwim, CanFly{\n    public void fly() {}\n    public void swim() {}\n}\n``` \n\n值得注意的是，Hero从AcationCharater继承而来的fight方法也成为了接口的实现，编译器并未因为写 Hero 类时并未给出fight方法而报错\n\n就thinging in java 推荐来看，如果我们要创建不带任何方法定义和成员变量的基类，我们应该选用接口，或者说是在我们知道某事物会成为一个基类，第一选择应该是让它成为一个接口\n\n### 通过继承来扩展接口 \n\n通过继承，可以很容易的在接口中添加新的方法，因为接口支持多继承，因此可以通过接口来组合多个接口\n\n    [修饰符] interface 接口名 [extends 父接口1, 父接口2 ... ] {\n        \n    }\n    \n    \n### 适配接口\n\n同一个接口，可以允许有多个不同的实现，其中一个体现就是一个接收接口类型的方法，该接口的实现和向该方法传递的对象取决于方法的使用者。\n\n一个常见常见的用法就是策略模式，我们编写一个执行某些操作的方法，该方法接收一个我们指定的接口。使用者只需要实现这个接口，那么就可以使用这个方法，通过这种原则，可以使得方法更加灵活，通用和更强的可复用性\n\n举个简单的例子，还是用排序算法来举例,只要使用者的类实现了Comparable，那么久可以将sort作用于它\n\n```java\npublic class Quick{\n    public static void sort(Comparable[] a)\n    {\n        //will call a.less()\n    }\n}\n\npublic interface Comparable {\n    bool less();\n}\n```\n\n### 接口中的域\n\n值得注意的是，接口中的域都是 static 和 final的，可以被非常量表达式初始化\n","slug":"java-polymorphism","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwbe001ud6jxy3cj9in0"},{"title":"Java 学习总结五 集合框架","date":"2015-12-10T06:34:52.000Z","_content":"\n当我们需要不知道具体多少个数量的对象时候，甚至是不知道对象的具体类型时，我们显然没法在代码里直接写的方式来表示这些对象\n\n\tType refer1;\n\tType refer2;\n\tType refer3;\n\t.\n\t.\n\t.\n\n这样是不可能的，因为不知道对象具体由多少个，所以我们需要编程语言提供一些机制来处理这个问题，Java有不少方式可以来解决这个问题，比如说数组，可以通过一个数组来持有多个对象，但是由于数组的长度是固定的，虽然我们可以申明足够大的容量来保证要用到的数量小于这个最大值，但我们很多时候希望由更灵活的方式来持有对象。\n在Java中，除了数组，我们还可以用List，Set，Queue，Map来持有对象，这些对象类型又被称为**集合类**\n\n#### 泛型和类型安全的容器\n\n在Java支持泛型之前，Java中所有类都集成于Object类，因此可以靠持有Object类来持有其他类，但正因为这样，就意味着所有的类都可以往容器里放，一不小心，就会出现类型错误\n在支持泛型之后，这个问题就得到了改善，可以通过泛型来保存一组容器，容器的类型会在编译时得到检测，这样就可以安全的持有对象\n\n```java\nimport java.util.ArrayList;\npublic class TestClass {\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<Integer>();\n        for(int i=0;i<5;i++) {\n            arr.add(i);\n        }\n        for(int i = 0; i< arr.size(); i++ ) {\n            System.out.println(arr.get(i));\n        }\n        for (Integer i : arr) {\n            System.out.println(arr.get(i));\n        }\n    }\n}\n```\n\n如果我们想要将一个Float对象放入arr中，那么在编译期就会报错，不再会是运行时错误，实现了类型安全\n\n#### Collection 与 Map\n\n1. Collection , 是一个接口，表示一个独立的序列，序列中的元素都服从一条或多条规则。由List， Set， Queue 三个子接口\n2. Map ， 一组成对的键值对 对象，允许通过键值来查找值，也被称为关联数组。\n\n\n#### List\n\nList 由两种实现，ArrayList和LinkedList， 我们可以把他们分别看做数组和链表，其特性也是跟数组和链表类似的，ArrayList的随机访问性能较好(0(1))，但是在链表中插入和移除元素代价较大(O(n))，LinkList 的随机访问性能较差(O(n))，但提供更好的插入和删除操作(O(1))\n\n\n#### 迭代器\n\n##### Iterator\n我们把容器的遍历操作抽象为迭代器的操作，这样我们就可以忽略掉不同容器的差异，使得代码的可复用能力更强，Java中的迭代器只能单向移动，只能用来:\n\n1. 使用iterator()方法来要求容器返回一个iterator\n2. 使用next() 获取下一个元素\n3. 使用hasNext()来判断是否还有元素\n4. 使用remove() 将迭代器返回的元素删除\n\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class TestClass {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        for (int i=0; i< 5; i++) {\n            list.add(\"\"+i);\n        }\n        System.out.println(list.toString());\n        Iterator<String> iter;\n        iter = list.iterator();\n        while(iter.hasNext()) {\n            iter.next();\n            iter.remove();\n        }\n        System.out.println(list.toString());\n    }\n}\n```\n\n##### ListIterator\n\nListIterator具有更强大的功能，它只能应用于List类的访问，可以双向移动，可以通过一个listIterator()方法产生一个指向List开头的ListIterator，也可以通过list(n) 产生一个指向列表索引为n的ListIterator\n\n#### Set\n\n如其字面意思，Set表示集合，Set中不保存重复的元素，由 HashSet， TreeSet， LinkedHashSet 几种实现，通过名字我们就可以知道，这几种实现分别是基于hash表(二次探测)， 二叉平衡树， hash表（链表来处理冲突） 实现的\n\n\n#### Java 中容器总结\n\nJava中提供了大量组织多个对象的方式\n\n1. 数组用来保存明确类型的对象，可以是多维的，可以保存基本类型，但是数组一旦生成，其容量不能发生改变\n2. Collection用来保存单一的元素，Map用来保存相关的键值对。通过Java的泛型，可以指定放入容器的元素类型，来保证类型安全。容器不能持有基本类型，但是通过包装类型的自动包装机制可以很好的执行容器持有包装类型和基本类型之间的转换\n3. 和数组类似，List具有相类似的功能，但是List可以自动扩容\n4. List由两种实现，一种是ArrayList，另一种是LinkedList，ArrayList具有更好的随机访问性能，LinkedList在中间插入和删除元素时具有更好的表现\n5. 各种Queue和栈的行为由LinkedList提供支持\n6. 提供Map\n7. 提供Set\n8. 新程序中不应该使用过时的Vector, Hashtable 和 Stack\n\n![](http://7q5fny.com1.z0.glb.clouddn.com/blogThinking%20in%20Java%204th%20Ed.jpg)","source":"_posts/java-hold-objects.md","raw":"title: Java 学习总结五 集合框架\ndate: 2015-12-10 14:34:52\ntags: [generic, java, object]\n---\n\n当我们需要不知道具体多少个数量的对象时候，甚至是不知道对象的具体类型时，我们显然没法在代码里直接写的方式来表示这些对象\n\n\tType refer1;\n\tType refer2;\n\tType refer3;\n\t.\n\t.\n\t.\n\n这样是不可能的，因为不知道对象具体由多少个，所以我们需要编程语言提供一些机制来处理这个问题，Java有不少方式可以来解决这个问题，比如说数组，可以通过一个数组来持有多个对象，但是由于数组的长度是固定的，虽然我们可以申明足够大的容量来保证要用到的数量小于这个最大值，但我们很多时候希望由更灵活的方式来持有对象。\n在Java中，除了数组，我们还可以用List，Set，Queue，Map来持有对象，这些对象类型又被称为**集合类**\n\n#### 泛型和类型安全的容器\n\n在Java支持泛型之前，Java中所有类都集成于Object类，因此可以靠持有Object类来持有其他类，但正因为这样，就意味着所有的类都可以往容器里放，一不小心，就会出现类型错误\n在支持泛型之后，这个问题就得到了改善，可以通过泛型来保存一组容器，容器的类型会在编译时得到检测，这样就可以安全的持有对象\n\n```java\nimport java.util.ArrayList;\npublic class TestClass {\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<Integer>();\n        for(int i=0;i<5;i++) {\n            arr.add(i);\n        }\n        for(int i = 0; i< arr.size(); i++ ) {\n            System.out.println(arr.get(i));\n        }\n        for (Integer i : arr) {\n            System.out.println(arr.get(i));\n        }\n    }\n}\n```\n\n如果我们想要将一个Float对象放入arr中，那么在编译期就会报错，不再会是运行时错误，实现了类型安全\n\n#### Collection 与 Map\n\n1. Collection , 是一个接口，表示一个独立的序列，序列中的元素都服从一条或多条规则。由List， Set， Queue 三个子接口\n2. Map ， 一组成对的键值对 对象，允许通过键值来查找值，也被称为关联数组。\n\n\n#### List\n\nList 由两种实现，ArrayList和LinkedList， 我们可以把他们分别看做数组和链表，其特性也是跟数组和链表类似的，ArrayList的随机访问性能较好(0(1))，但是在链表中插入和移除元素代价较大(O(n))，LinkList 的随机访问性能较差(O(n))，但提供更好的插入和删除操作(O(1))\n\n\n#### 迭代器\n\n##### Iterator\n我们把容器的遍历操作抽象为迭代器的操作，这样我们就可以忽略掉不同容器的差异，使得代码的可复用能力更强，Java中的迭代器只能单向移动，只能用来:\n\n1. 使用iterator()方法来要求容器返回一个iterator\n2. 使用next() 获取下一个元素\n3. 使用hasNext()来判断是否还有元素\n4. 使用remove() 将迭代器返回的元素删除\n\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class TestClass {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        for (int i=0; i< 5; i++) {\n            list.add(\"\"+i);\n        }\n        System.out.println(list.toString());\n        Iterator<String> iter;\n        iter = list.iterator();\n        while(iter.hasNext()) {\n            iter.next();\n            iter.remove();\n        }\n        System.out.println(list.toString());\n    }\n}\n```\n\n##### ListIterator\n\nListIterator具有更强大的功能，它只能应用于List类的访问，可以双向移动，可以通过一个listIterator()方法产生一个指向List开头的ListIterator，也可以通过list(n) 产生一个指向列表索引为n的ListIterator\n\n#### Set\n\n如其字面意思，Set表示集合，Set中不保存重复的元素，由 HashSet， TreeSet， LinkedHashSet 几种实现，通过名字我们就可以知道，这几种实现分别是基于hash表(二次探测)， 二叉平衡树， hash表（链表来处理冲突） 实现的\n\n\n#### Java 中容器总结\n\nJava中提供了大量组织多个对象的方式\n\n1. 数组用来保存明确类型的对象，可以是多维的，可以保存基本类型，但是数组一旦生成，其容量不能发生改变\n2. Collection用来保存单一的元素，Map用来保存相关的键值对。通过Java的泛型，可以指定放入容器的元素类型，来保证类型安全。容器不能持有基本类型，但是通过包装类型的自动包装机制可以很好的执行容器持有包装类型和基本类型之间的转换\n3. 和数组类似，List具有相类似的功能，但是List可以自动扩容\n4. List由两种实现，一种是ArrayList，另一种是LinkedList，ArrayList具有更好的随机访问性能，LinkedList在中间插入和删除元素时具有更好的表现\n5. 各种Queue和栈的行为由LinkedList提供支持\n6. 提供Map\n7. 提供Set\n8. 新程序中不应该使用过时的Vector, Hashtable 和 Stack\n\n![](http://7q5fny.com1.z0.glb.clouddn.com/blogThinking%20in%20Java%204th%20Ed.jpg)","slug":"java-hold-objects","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwbj0021d6jxj44aprmj"},{"title":"java 学习总结六 文件操作","date":"2015-12-11T12:51:24.000Z","_content":"\n#### File 类\n\n```java\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.util.regex.Pattern;\n\npublic class TestClass {\n    public static void main(String[] args) {\n        File path = new File(\".\");\n        String[] list;\n        list  = path.list(new DirFilter());\n        for(String str : list) {\n            System.out.println(str);\n        }\n    }\n}\n\nclass DirFilter implements FilenameFilter{\n    private Pattern pattern;\n    public DirFilter(){\n        pattern = Pattern.compile(\".*\\\\.java\");\n    }\n    public boolean accept(File dir, String name) {\n        return pattern.matcher(name).matches();\n    }\n}\n```\n这段代码匹展示出了列出当前目录下以.java结尾的文件功能   其中用到了File类和FilenameFilter接口\n\n\n#### 目录的检查及创建\n\n```java\nimport java.io.*;\npublic class MakeDirectories {\n    public static void main(String[] args) {\n        if(args.length < 1) {\n            System.exit(1);\n        } else if (args[0].equals(\"-r\")) {\n            File old = new File(args[1]), rname = new File(args[2]);\n            old.renameTo(rname);\n            return;\n        }\n        int count = 0;\n        boolean del = false;\n        if(args[0].equals(\"-d\")) {\n            count ++;\n            del = true;\n        }\n        count -- ;\n        while (++count < args.length) {\n            File f = new File(args[count]);\n            if(f.exists()) {\n                System.out.println(\"正在删除文件\" + f);\n                f.delete();\n            }\n            else {\n                if(!del) {\n                    f.mkdirs();\n                    System.out.println(\"创建文件\" + f);\n                }\n            }\n        }\n    }\n}\n\n```\n以上代码展示了文件的创建，重命名，删除操作\n\n#### 输入和输出\n\n编程语言的I/O库中通常使用流这个概念， 它代表任何由能力产出数据的数据源对象或者由能力接受数据的借手段对象。流 屏蔽了实际的I/0设备中处理数据的细节。\n在Java中，任何从InputStream或Reader派生而来的类都含有名为()的基本方法，用于读取单个字节或者字节数组。任何从OutputStream或Writer派生而来的类都含有write()方法，用于写单个字节或者字节数组。\n\n##### InputStream类型\n\n\n|类 | 功能 | 说明 |\n|--|---|----|\n|ByteArrayInputStream|允许将内存的缓冲区当作InputStream使用|构造参数为缓冲区。字节将从中取出。将其于FilterInputStream对象相连以提供游泳的借口|\n|StringBufferInputStream|将String转换为InputStream|构造参数为字符串。将其于FilterInputStream对象相连以提供游泳的借口|\n|FileInputStream|用于从文件中读取信息|使用文件名，文件，或FileDescriptor进行构造。将其于FilterInputStream对象相连以提供游泳的借口|\n|PipedInputStream|产生用于写入相关PipedOutputStream的数据。实现管道化概念|构造参数为PipedOutputStream。将其于FilterInputStream对象相连以提供游泳的借口|\n|SequenceInputSteam|将两个或者多个InputStream对象转换为单一InputStream|构造参数为两个InputStream对象或者一个容纳InputStream对象的容器Enumeration。。将其于FilterInputStream对象相连以提供游泳的借口|\n|FilterInputStream|抽象类，作为装饰器借口。其中装饰器为其他的InputStream类提供有用的功能||\n\n##### OutputStream类型\n\n|类 | 功能 | 说明 |\n|--|---|----|\n|ByteArrayOutputStream|内存中创建缓冲区，所有送往流的数据都要放置在此缓冲区|构造参数为缓冲区初始化尺寸(可选)。字节将从中取出。将其于FilterOutputStream对象相连以提供游泳的借口|\n|FileOutputStream|用于将信息写入文件|使用文件名，文件，或FileDescriptor进行构造。将其于FilterOutputStream对象相连以提供游泳的借口|\n|PipedOutputStream|任何写入其中的信息都会自动作为相关PipedInputStream的输出。实现管道化概念|构造参数为PipedInputStream，指定用于多线程的数据的目的地。将其于FilterOutputStream对象相连以提供游泳的借口|\n|SequenceInputSteam|将两个或者多个InputStream对象转换为单一InputStream|构造参数为两个InputStream对象或者一个容纳InputStream对象的容器Enumeration。。将其于FilterInputStream对象相连以提供游泳的借口|\n|FilterOutputStream|抽象类，作为装饰器借口。其中装饰器为其他的OutputStream类提供有用的功能||\n\n##### FiterInputStream\n\n|类|功能|构造器参数|如何使用|\n|--|---|---|---|\n|DataInputStream|与DataOutputStream搭配使用，因此我们可以按照可移植方式从流读取基本数据类型|InputStream|包含读取基本类型数据的全部接口|\n|BufferedInputStram|使用它可以防止每次读取时都得进行实际操作。代表使用缓冲区|InputStream，可以指定缓冲区大小(可选的)|本质上不提供接口，只不过是向进程中添加缓冲区所必须的。与借口对象搭配|\n|LineNumberInputStream|跟踪输入流中的行号，可以调用getLineNumber()和setLineNumber(int)|InputStream|仅增加了行号，因此可能要与借口对象配合使用|\n|PushbackInputStream|具有 能\"弹出一个字节的缓冲区\"。因此可以将读到的最后一个字符回退|InputStream|通常为编译器的扫描器|\n\n\n##### FiterOutputStream\n\n|类|功能|构造器参数|如何使用|\n|--|---|---|---|\n|DataOutputStream|与DataInputputStream搭配使用，因此我们可以按照可移植方式从流读取基本数据类型|OutputStream|包含读取基本类型数据的全部接口|\n|PrintStram|用于产生格式化输出。其中DataOutputStream处理数据的存储，PrintStream处理显示|OutputStream，可以指定缓冲区大小(可选的)|本质上不提供接口，只不过是向进程中添加缓冲区所必须的。与借口对象搭配|\n|BufferedOutputStream|使用它可以避免每次发送数据时都要进行实际操作，可以调用flush()清空缓冲区|OutputStream|仅增加了行号，因此可能要与借口对象配合使用|\n\n\n```java\nimport java.io.*;\n\n/**\n * Created by xiejun on 2015/12/17.\n */\npublic class TestClass {\n    public static void main(String[] args) throws Exception{\n        //ByteArrayInputStream 测试\n        testByteArrayInputStream();\n        //FileInputStream 测试\n        testFileInputStream();\n        //StringBufferInputStream()\n        testStringBufferInputStream();\n\n    }\n\n    /**\n     * ByteArrayInputStream 类测试\n     */\n    public static void testByteArrayInputStream() {\n        byte[] bytes = new byte[10];\n        for(int i=0; i< bytes.length; i++) {\n            bytes[i] = (byte)i;\n        }\n        ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);\n        DataInputStream dis = new DataInputStream(byteStream);\n        try {\n            while (true) {\n                byte b = dis.readByte();\n                System.out.println(b);\n            }\n        } catch (EOFException e1) {\n            System.out.println(\"ending\");\n        } catch (IOException e2) {\n            System.out.println(\"IO error\");\n        }\n    }\n\n    /**\n     * FileInputStream 测试\n     */\n    public static void testFileInputStream() {\n        //构造参数为字符串的文件名\n        try {\n            FileInputStream fs = new FileInputStream(new File(\"data.txt\"));\n            DataInputStream dis = new DataInputStream(fs);\n            while(true) {\n                byte value = dis.readByte();\n                System.out.println(value);\n            }\n        } catch (EOFException e) {\n            System.out.println(\"read finish\");\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    /**\n     *StringBufferInputStream 测试\n     */\n    public static void testStringBufferInputStream() {\n        try{\n            StringBufferInputStream sbis = new StringBufferInputStream(\"123 456\");\n            DataInputStream dis = new DataInputStream(sbis);\n            while(true) {\n                byte value = dis.readByte();\n                System.out.println(value);\n            }\n        } catch (EOFException e) {\n            System.out.println(\"read finish\");\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n#### Reader 和 Writer\n\n之前提到的I/O流只支持9位字节流，并不能很好的处理16位的Unicode字符。Reader和Writer是为了在所有的I/o操作中都支持Unicode\n\n```java\nimport java.io.*;\n\n/**\n * Created by xiejun on 2015/12/17.\n */\npublic class IoClass {\n    public static void main(String[] args) throws Exception{\n        testReadter();\n\n    }\n\n    /**\n     * Reader 测试\n     */\n    public static void testReadter() {\n        System.out.println(\"测试Reader\");\n        try {\n            FileReader fr = new FileReader(\"data.txt\");\n            System.out.println(fr.getEncoding());\n            char[] value = new char[100];\n            fr.read(value);\n            System.out.println(value);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n````\n\n#### RandomAccessFile\n\nRandomAccessFile 适用于由大小移植的记录组成的文件，所以我们可以使用()将记录从一处转移到另一处，然后读取或者修改记录， RandomAccessFile 不属于 InputStream 和 OutputStream继承体系。\n\n```java\npublic static void testRandomAccessFile() {\n    System.out.println(\"测试RandomAccessFile\");\n    try {\n        RandomAccessFile raf = new RandomAccessFile(\"data.txt\", \"rw\");\n        byte[] value =  new byte[10];\n        raf.seek(3);\n        raf.read(value);\n        for(byte b : value) {\n            System.out.println(b);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n#### 对象的序列化与反序列化\n\n将对象从Object转换为byte序列称为对象的序列化，反之则是对象的反序列化\n对象必须实现Serializable借口才能进行序列化，否则将出现异常\n\n一个简单的例子\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\n/**\n * Created by xiejun on 2015/12/18.\n */\npublic class TestClass {\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"data.txt\"));\n            String s = \"xxxx\";\n            oos.writeObject(s);\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"data.txt\"));\n            String s1;\n            s1 = (String)ois.readObject();\n            System.out.println(s1);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### Java 中的XML\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\t<book id = \"1\">\n\t\t<name>冰与火之歌</name>\n\t\t<author>乔治马丁</author>\n\t</book>\n\t<book id = \"2\">\n\t\t<name>安徒生童话</name>\n\t\t<year>2004</year>\n\t</book>\n</bookstore>\n```\n\nXML的作用是用于数据共享，用于不同应用程序之间，不同操作系统之间，不同平台间的数据共享。\n\n##### 通过 DOM 来解析XML文件\n\n在 Java 中，解析XML文件有以下集中方式\n\n1. DOM\n2. SAX\n3. DOM4J\n4. JDOM\n\n其中 DOM 和 SAX 解析是 Java 官方提供的， DOM 和 JDOM 解析是第三方库提供的，以下为一小部分的例子\n\n```java\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\npublic class TestClass {\n    public static void main(String[] args) {\n        DocumentBuilderFactory xmlParser = DocumentBuilderFactory.newInstance();\n        try {\n            DocumentBuilder docBuilder =  xmlParser.newDocumentBuilder();\n            Document doc = docBuilder.parse(\"bookstore.xml\");\n            NodeList bookList = doc.getElementsByTagName(\"book\");\n            System.out.println(bookList.getLength());\n            for (int i=0; i<bookList.getLength(); i++) {\n                Node book = bookList.item(i);\n                NamedNodeMap attrs = book.getAttributes();\n                for(int j=0; j<attrs.getLength();j++) {\n                    System.out.println(attrs.item(j).getNodeName() + \":\" + attrs.item(j).getNodeValue());\n                }\n                NodeList childNodes = book.getChildNodes();\n                System.out.println(childNodes.getLength());\n                for (int j=0; j < childNodes.getLength();j++) {\n                    Node childNode = childNodes.item(j);\n                    if (childNode.getNodeType() == Node.ELEMENT_NODE) {\n                        System.out.println(childNode.getNodeName() );\n                        System.out.println(childNode.getFirstChild().getNodeValue());\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n```\n\n##### 通过 SAX 来解析XML文件\n\n```java\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\npublic class SAXTest {\n    public static void main(String[] args) {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        try {\n            SAXParser parser = factory.newSAXParser();\n            SAXParserHandler hd = new SAXParserHandler();\n            parser.parse(\"bookstore.xml\",hd);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n\npublic class SAXParserHandler extends DefaultHandler{\n\n    public int bookIndex = 0;\n    @Override\n    public void startDocument() throws SAXException {\n        super.startDocument();\n        System.out.println(\"开始解析\");\n    }\n\n    @Override\n    public void endDocument() throws SAXException {\n        super.endDocument();\n        System.out.println(\"结束解析\");\n    }\n\n    @Override\n    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n        super.startElement(uri, localName, qName, attributes);\n        if (qName.equals(\"book\")) {\n            bookIndex++;\n            //创建一个book对象\n            System.out.println(\"======================开始遍历某一本书的内容=================\");\n            int num = attributes.getLength();\n            for(int i = 0; i < num; i++){\n                System.out.print(\"book元素的第\" + (i + 1) +  \"个属性名是：\"\n                        + attributes.getQName(i));\n                System.out.println(\"---属性值是：\" + attributes.getValue(i));\n            }\n        }\n        else if (!qName.equals(\"name\") && !qName.equals(\"bookstore\")) {\n            System.out.print(\"节点名是：\" + qName + \"---\");\n        }\n    }\n\n    @Override\n    public void endElement(String uri, String localName, String qName) throws SAXException {\n        super.endElement(uri, localName, qName);\n        if (qName == \"book\") {\n            System.out.println(\"======================结束遍历某一本书的内容=================\");\n        }\n    }\n}\n\n\n```","source":"_posts/java-fileio.md","raw":"title: java 学习总结六 文件操作\ndate: 2015-12-11 20:51:24\ntags: [file, java, io]\n---\n\n#### File 类\n\n```java\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.util.regex.Pattern;\n\npublic class TestClass {\n    public static void main(String[] args) {\n        File path = new File(\".\");\n        String[] list;\n        list  = path.list(new DirFilter());\n        for(String str : list) {\n            System.out.println(str);\n        }\n    }\n}\n\nclass DirFilter implements FilenameFilter{\n    private Pattern pattern;\n    public DirFilter(){\n        pattern = Pattern.compile(\".*\\\\.java\");\n    }\n    public boolean accept(File dir, String name) {\n        return pattern.matcher(name).matches();\n    }\n}\n```\n这段代码匹展示出了列出当前目录下以.java结尾的文件功能   其中用到了File类和FilenameFilter接口\n\n\n#### 目录的检查及创建\n\n```java\nimport java.io.*;\npublic class MakeDirectories {\n    public static void main(String[] args) {\n        if(args.length < 1) {\n            System.exit(1);\n        } else if (args[0].equals(\"-r\")) {\n            File old = new File(args[1]), rname = new File(args[2]);\n            old.renameTo(rname);\n            return;\n        }\n        int count = 0;\n        boolean del = false;\n        if(args[0].equals(\"-d\")) {\n            count ++;\n            del = true;\n        }\n        count -- ;\n        while (++count < args.length) {\n            File f = new File(args[count]);\n            if(f.exists()) {\n                System.out.println(\"正在删除文件\" + f);\n                f.delete();\n            }\n            else {\n                if(!del) {\n                    f.mkdirs();\n                    System.out.println(\"创建文件\" + f);\n                }\n            }\n        }\n    }\n}\n\n```\n以上代码展示了文件的创建，重命名，删除操作\n\n#### 输入和输出\n\n编程语言的I/O库中通常使用流这个概念， 它代表任何由能力产出数据的数据源对象或者由能力接受数据的借手段对象。流 屏蔽了实际的I/0设备中处理数据的细节。\n在Java中，任何从InputStream或Reader派生而来的类都含有名为()的基本方法，用于读取单个字节或者字节数组。任何从OutputStream或Writer派生而来的类都含有write()方法，用于写单个字节或者字节数组。\n\n##### InputStream类型\n\n\n|类 | 功能 | 说明 |\n|--|---|----|\n|ByteArrayInputStream|允许将内存的缓冲区当作InputStream使用|构造参数为缓冲区。字节将从中取出。将其于FilterInputStream对象相连以提供游泳的借口|\n|StringBufferInputStream|将String转换为InputStream|构造参数为字符串。将其于FilterInputStream对象相连以提供游泳的借口|\n|FileInputStream|用于从文件中读取信息|使用文件名，文件，或FileDescriptor进行构造。将其于FilterInputStream对象相连以提供游泳的借口|\n|PipedInputStream|产生用于写入相关PipedOutputStream的数据。实现管道化概念|构造参数为PipedOutputStream。将其于FilterInputStream对象相连以提供游泳的借口|\n|SequenceInputSteam|将两个或者多个InputStream对象转换为单一InputStream|构造参数为两个InputStream对象或者一个容纳InputStream对象的容器Enumeration。。将其于FilterInputStream对象相连以提供游泳的借口|\n|FilterInputStream|抽象类，作为装饰器借口。其中装饰器为其他的InputStream类提供有用的功能||\n\n##### OutputStream类型\n\n|类 | 功能 | 说明 |\n|--|---|----|\n|ByteArrayOutputStream|内存中创建缓冲区，所有送往流的数据都要放置在此缓冲区|构造参数为缓冲区初始化尺寸(可选)。字节将从中取出。将其于FilterOutputStream对象相连以提供游泳的借口|\n|FileOutputStream|用于将信息写入文件|使用文件名，文件，或FileDescriptor进行构造。将其于FilterOutputStream对象相连以提供游泳的借口|\n|PipedOutputStream|任何写入其中的信息都会自动作为相关PipedInputStream的输出。实现管道化概念|构造参数为PipedInputStream，指定用于多线程的数据的目的地。将其于FilterOutputStream对象相连以提供游泳的借口|\n|SequenceInputSteam|将两个或者多个InputStream对象转换为单一InputStream|构造参数为两个InputStream对象或者一个容纳InputStream对象的容器Enumeration。。将其于FilterInputStream对象相连以提供游泳的借口|\n|FilterOutputStream|抽象类，作为装饰器借口。其中装饰器为其他的OutputStream类提供有用的功能||\n\n##### FiterInputStream\n\n|类|功能|构造器参数|如何使用|\n|--|---|---|---|\n|DataInputStream|与DataOutputStream搭配使用，因此我们可以按照可移植方式从流读取基本数据类型|InputStream|包含读取基本类型数据的全部接口|\n|BufferedInputStram|使用它可以防止每次读取时都得进行实际操作。代表使用缓冲区|InputStream，可以指定缓冲区大小(可选的)|本质上不提供接口，只不过是向进程中添加缓冲区所必须的。与借口对象搭配|\n|LineNumberInputStream|跟踪输入流中的行号，可以调用getLineNumber()和setLineNumber(int)|InputStream|仅增加了行号，因此可能要与借口对象配合使用|\n|PushbackInputStream|具有 能\"弹出一个字节的缓冲区\"。因此可以将读到的最后一个字符回退|InputStream|通常为编译器的扫描器|\n\n\n##### FiterOutputStream\n\n|类|功能|构造器参数|如何使用|\n|--|---|---|---|\n|DataOutputStream|与DataInputputStream搭配使用，因此我们可以按照可移植方式从流读取基本数据类型|OutputStream|包含读取基本类型数据的全部接口|\n|PrintStram|用于产生格式化输出。其中DataOutputStream处理数据的存储，PrintStream处理显示|OutputStream，可以指定缓冲区大小(可选的)|本质上不提供接口，只不过是向进程中添加缓冲区所必须的。与借口对象搭配|\n|BufferedOutputStream|使用它可以避免每次发送数据时都要进行实际操作，可以调用flush()清空缓冲区|OutputStream|仅增加了行号，因此可能要与借口对象配合使用|\n\n\n```java\nimport java.io.*;\n\n/**\n * Created by xiejun on 2015/12/17.\n */\npublic class TestClass {\n    public static void main(String[] args) throws Exception{\n        //ByteArrayInputStream 测试\n        testByteArrayInputStream();\n        //FileInputStream 测试\n        testFileInputStream();\n        //StringBufferInputStream()\n        testStringBufferInputStream();\n\n    }\n\n    /**\n     * ByteArrayInputStream 类测试\n     */\n    public static void testByteArrayInputStream() {\n        byte[] bytes = new byte[10];\n        for(int i=0; i< bytes.length; i++) {\n            bytes[i] = (byte)i;\n        }\n        ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);\n        DataInputStream dis = new DataInputStream(byteStream);\n        try {\n            while (true) {\n                byte b = dis.readByte();\n                System.out.println(b);\n            }\n        } catch (EOFException e1) {\n            System.out.println(\"ending\");\n        } catch (IOException e2) {\n            System.out.println(\"IO error\");\n        }\n    }\n\n    /**\n     * FileInputStream 测试\n     */\n    public static void testFileInputStream() {\n        //构造参数为字符串的文件名\n        try {\n            FileInputStream fs = new FileInputStream(new File(\"data.txt\"));\n            DataInputStream dis = new DataInputStream(fs);\n            while(true) {\n                byte value = dis.readByte();\n                System.out.println(value);\n            }\n        } catch (EOFException e) {\n            System.out.println(\"read finish\");\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    /**\n     *StringBufferInputStream 测试\n     */\n    public static void testStringBufferInputStream() {\n        try{\n            StringBufferInputStream sbis = new StringBufferInputStream(\"123 456\");\n            DataInputStream dis = new DataInputStream(sbis);\n            while(true) {\n                byte value = dis.readByte();\n                System.out.println(value);\n            }\n        } catch (EOFException e) {\n            System.out.println(\"read finish\");\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n#### Reader 和 Writer\n\n之前提到的I/O流只支持9位字节流，并不能很好的处理16位的Unicode字符。Reader和Writer是为了在所有的I/o操作中都支持Unicode\n\n```java\nimport java.io.*;\n\n/**\n * Created by xiejun on 2015/12/17.\n */\npublic class IoClass {\n    public static void main(String[] args) throws Exception{\n        testReadter();\n\n    }\n\n    /**\n     * Reader 测试\n     */\n    public static void testReadter() {\n        System.out.println(\"测试Reader\");\n        try {\n            FileReader fr = new FileReader(\"data.txt\");\n            System.out.println(fr.getEncoding());\n            char[] value = new char[100];\n            fr.read(value);\n            System.out.println(value);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n````\n\n#### RandomAccessFile\n\nRandomAccessFile 适用于由大小移植的记录组成的文件，所以我们可以使用()将记录从一处转移到另一处，然后读取或者修改记录， RandomAccessFile 不属于 InputStream 和 OutputStream继承体系。\n\n```java\npublic static void testRandomAccessFile() {\n    System.out.println(\"测试RandomAccessFile\");\n    try {\n        RandomAccessFile raf = new RandomAccessFile(\"data.txt\", \"rw\");\n        byte[] value =  new byte[10];\n        raf.seek(3);\n        raf.read(value);\n        for(byte b : value) {\n            System.out.println(b);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n#### 对象的序列化与反序列化\n\n将对象从Object转换为byte序列称为对象的序列化，反之则是对象的反序列化\n对象必须实现Serializable借口才能进行序列化，否则将出现异常\n\n一个简单的例子\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\n/**\n * Created by xiejun on 2015/12/18.\n */\npublic class TestClass {\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"data.txt\"));\n            String s = \"xxxx\";\n            oos.writeObject(s);\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"data.txt\"));\n            String s1;\n            s1 = (String)ois.readObject();\n            System.out.println(s1);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### Java 中的XML\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\t<book id = \"1\">\n\t\t<name>冰与火之歌</name>\n\t\t<author>乔治马丁</author>\n\t</book>\n\t<book id = \"2\">\n\t\t<name>安徒生童话</name>\n\t\t<year>2004</year>\n\t</book>\n</bookstore>\n```\n\nXML的作用是用于数据共享，用于不同应用程序之间，不同操作系统之间，不同平台间的数据共享。\n\n##### 通过 DOM 来解析XML文件\n\n在 Java 中，解析XML文件有以下集中方式\n\n1. DOM\n2. SAX\n3. DOM4J\n4. JDOM\n\n其中 DOM 和 SAX 解析是 Java 官方提供的， DOM 和 JDOM 解析是第三方库提供的，以下为一小部分的例子\n\n```java\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\npublic class TestClass {\n    public static void main(String[] args) {\n        DocumentBuilderFactory xmlParser = DocumentBuilderFactory.newInstance();\n        try {\n            DocumentBuilder docBuilder =  xmlParser.newDocumentBuilder();\n            Document doc = docBuilder.parse(\"bookstore.xml\");\n            NodeList bookList = doc.getElementsByTagName(\"book\");\n            System.out.println(bookList.getLength());\n            for (int i=0; i<bookList.getLength(); i++) {\n                Node book = bookList.item(i);\n                NamedNodeMap attrs = book.getAttributes();\n                for(int j=0; j<attrs.getLength();j++) {\n                    System.out.println(attrs.item(j).getNodeName() + \":\" + attrs.item(j).getNodeValue());\n                }\n                NodeList childNodes = book.getChildNodes();\n                System.out.println(childNodes.getLength());\n                for (int j=0; j < childNodes.getLength();j++) {\n                    Node childNode = childNodes.item(j);\n                    if (childNode.getNodeType() == Node.ELEMENT_NODE) {\n                        System.out.println(childNode.getNodeName() );\n                        System.out.println(childNode.getFirstChild().getNodeValue());\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n```\n\n##### 通过 SAX 来解析XML文件\n\n```java\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\npublic class SAXTest {\n    public static void main(String[] args) {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        try {\n            SAXParser parser = factory.newSAXParser();\n            SAXParserHandler hd = new SAXParserHandler();\n            parser.parse(\"bookstore.xml\",hd);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n\npublic class SAXParserHandler extends DefaultHandler{\n\n    public int bookIndex = 0;\n    @Override\n    public void startDocument() throws SAXException {\n        super.startDocument();\n        System.out.println(\"开始解析\");\n    }\n\n    @Override\n    public void endDocument() throws SAXException {\n        super.endDocument();\n        System.out.println(\"结束解析\");\n    }\n\n    @Override\n    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n        super.startElement(uri, localName, qName, attributes);\n        if (qName.equals(\"book\")) {\n            bookIndex++;\n            //创建一个book对象\n            System.out.println(\"======================开始遍历某一本书的内容=================\");\n            int num = attributes.getLength();\n            for(int i = 0; i < num; i++){\n                System.out.print(\"book元素的第\" + (i + 1) +  \"个属性名是：\"\n                        + attributes.getQName(i));\n                System.out.println(\"---属性值是：\" + attributes.getValue(i));\n            }\n        }\n        else if (!qName.equals(\"name\") && !qName.equals(\"bookstore\")) {\n            System.out.print(\"节点名是：\" + qName + \"---\");\n        }\n    }\n\n    @Override\n    public void endElement(String uri, String localName, String qName) throws SAXException {\n        super.endElement(uri, localName, qName);\n        if (qName == \"book\") {\n            System.out.println(\"======================结束遍历某一本书的内容=================\");\n        }\n    }\n}\n\n\n```","slug":"java-fileio","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwbn0027d6jxcalfxc2z"},{"title":"Java 学习总结二  异常","date":"2015-12-05T14:10:59.000Z","_content":"\n### 异常的基本概念\n\n为什么需要异常呢？ 在程序运行中，总是会出错的，错误的处理一直以来都是各个程序语言需要处理的问题，在C语言中，错误一般是通过返回值和全局错误标识来进行表示的，这是一种约定俗称的方法，这样的方法比较原始，在比较现代的语言,例如Python， PHP, C++, Java 都支持通过异常来处理错误\n通过异常，我们可以在错误出现时，实行合适的操作来处理错误\n\n#### 抛出异常\n\n抛出异常通过关键字 throw 来实现\n\n```java\n\tif(t == null)\n\t\tthrow new NullPointerException()\n```\n\n在Java中，异常和其他对象一样，通过new 在堆上创建。标准异常类有两个构造器:一个是默认构造器，另外一个是以字符串作为参数，可以将相关信息放入异常对象中\n\n当抛出异常时，函数会从方法或者作用域中退出(类似于 return的效果)\n\n#### 异常捕获\n\n通过try...catch...finally 来进行异常的捕获和处理\n\n```java\npackage exception_sample;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\npublic class TestClass {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        try {\n            System.out.println(\"input a integer\");\n            int one = input.nextInt();\n        } catch (InputMismatchException e) {\n            System.out.println(\"input doesn't matche, pliease input ainteger\");\n        }\n    }\n}\n```\n\n#### 异常匹配\n\n抛出异常的时候，异常处理系统会按照代码书写的顺序找出最近的处理程序，找到匹配的处理程序之后，便会认为异常已经得到处理，不再继续查找，查找的时候不要求完全匹配，派生类的对象也可以匹配其积累的处理程序，因此在写catch的时候要将派生类写在前面，基类写在后面\n\n```java\nclass Annoyance extends Exception{\n\n}\n\nclass Sneeze extends Annoyance{\n\n}\n\npublic class TestClass {\n    public static void main(String[] args) {\n        try{\n            throw new Sneeze();\n        } catch (Sneeze s) {\n            System.out.println(\"Caught Sneeze\");\n        } catch (Annoyance a) {\n            System.out.println(\"Caught Annoyance\");\n        }\n        try{\n            throw new Sneeze();\n        } catch (Annoyance a) {\n            System.out.println(\"Caught Annoyance\");\n        }\n    }\n}\n\n```\n\n#### 经验总结\n\n1. 处理运行时异常时候，采用逻辑去合理规避同时辅助try-catch处理\n2. 在多重catch块后面，可以加一个catche(Exception) 来处理可能会被遗漏的异常\n3. 对于不确定的代码，也可以加上try-catch，处理潜在的异常\n4. 尽量去处理异常， 不要只是简单调用printStackTrace()去打印\n5. 具体如何处理异常，要根据不同的业务需求和异常类型去决定\n6. 尽量添加finally语句块去释放占用的资源\n","source":"_posts/java-exception.md","raw":"title: Java 学习总结二  异常\ndate: 2015-12-05 22:10:59\ntags: [异常, exception]\n---\n\n### 异常的基本概念\n\n为什么需要异常呢？ 在程序运行中，总是会出错的，错误的处理一直以来都是各个程序语言需要处理的问题，在C语言中，错误一般是通过返回值和全局错误标识来进行表示的，这是一种约定俗称的方法，这样的方法比较原始，在比较现代的语言,例如Python， PHP, C++, Java 都支持通过异常来处理错误\n通过异常，我们可以在错误出现时，实行合适的操作来处理错误\n\n#### 抛出异常\n\n抛出异常通过关键字 throw 来实现\n\n```java\n\tif(t == null)\n\t\tthrow new NullPointerException()\n```\n\n在Java中，异常和其他对象一样，通过new 在堆上创建。标准异常类有两个构造器:一个是默认构造器，另外一个是以字符串作为参数，可以将相关信息放入异常对象中\n\n当抛出异常时，函数会从方法或者作用域中退出(类似于 return的效果)\n\n#### 异常捕获\n\n通过try...catch...finally 来进行异常的捕获和处理\n\n```java\npackage exception_sample;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\npublic class TestClass {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        try {\n            System.out.println(\"input a integer\");\n            int one = input.nextInt();\n        } catch (InputMismatchException e) {\n            System.out.println(\"input doesn't matche, pliease input ainteger\");\n        }\n    }\n}\n```\n\n#### 异常匹配\n\n抛出异常的时候，异常处理系统会按照代码书写的顺序找出最近的处理程序，找到匹配的处理程序之后，便会认为异常已经得到处理，不再继续查找，查找的时候不要求完全匹配，派生类的对象也可以匹配其积累的处理程序，因此在写catch的时候要将派生类写在前面，基类写在后面\n\n```java\nclass Annoyance extends Exception{\n\n}\n\nclass Sneeze extends Annoyance{\n\n}\n\npublic class TestClass {\n    public static void main(String[] args) {\n        try{\n            throw new Sneeze();\n        } catch (Sneeze s) {\n            System.out.println(\"Caught Sneeze\");\n        } catch (Annoyance a) {\n            System.out.println(\"Caught Annoyance\");\n        }\n        try{\n            throw new Sneeze();\n        } catch (Annoyance a) {\n            System.out.println(\"Caught Annoyance\");\n        }\n    }\n}\n\n```\n\n#### 经验总结\n\n1. 处理运行时异常时候，采用逻辑去合理规避同时辅助try-catch处理\n2. 在多重catch块后面，可以加一个catche(Exception) 来处理可能会被遗漏的异常\n3. 对于不确定的代码，也可以加上try-catch，处理潜在的异常\n4. 尽量去处理异常， 不要只是简单调用printStackTrace()去打印\n5. 具体如何处理异常，要根据不同的业务需求和异常类型去决定\n6. 尽量添加finally语句块去释放占用的资源\n","slug":"java-exception","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwbq002dd6jxjmvuf6th"},{"title":"Java 学习总结四 Java中的常用类","date":"2015-12-08T02:17:51.000Z","_content":"\n#### Java 中的包装类\n\n为了使Java中的基本数据类型，int, float, doubtl, boolean, char等表现得跟类一样，为每个基本类型提供了一个包装类(Wrapper type)\n\n|基本类型|包装类型|\n|----|----|\n|byte|Byte|\n|short|Short|\n|int|Integer|\n|long|Long|\n|float|Float|\n|double|Double|\n|char|Character|\n|boolean|Boolean|\n\n包装类主要提供两大类方法\n\n1. 将本类型和其他基本类型进行转换\n2. 将字符串和本类型及包装类的相互转换\n\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        \n\t\t// 定义int类型变量，值为86\n\t\tint score1 = 86; \n        \n\t\t// 创建Integer包装类对象，表示变量score1的值\n\t\tInteger score2=new Integer(score1);\n        \n\t\t// 将Integer包装类转换为double类型\n\t\tdouble score3=score2.doubleValue();\n        \n\t\t// 将Integer包装类转换为float类型\n\t\tfloat score4=score2.floatValue();\n        \n\t\t// 将Integer包装类转换为int类型\n\t\tint score5 =score2.intValue();\n\n\t\tSystem.out.println(\"Integer包装类：\" + score2);\n\t\tSystem.out.println(\"double类型：\" + score3);\n\t\tSystem.out.println(\"float类型：\" + score4);\n\t\tSystem.out.println(\"int类型：\" + score5);\n\t}\n}\n```\n\n##### 包装类和基本类型的相互转换\n\n可以通过两种方式完成包装类和基本类型的换换\n\n手动转换\n\n\tWrapperType wp = new WrapperType(someBuildInType)  \n\tBuildInType  t = someWrapperType.BuildInTypeValue()\n\n自动转换\n\n\tWrapperType wp = someBuildInType;\n\tBuildInType t = someWrapperType\n\t\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        \n        // 定义double类型变量\n\t\tdouble a = 91.5;\n        \n         // 手动装箱\n\t\tDouble b =  new Double(a);      \n        \n        // 自动装箱\n\t\tDouble c =    a;   \n\n        System.out.println(\"装箱后的结果为：\" + b + \"和\" + c);\n        \n        // 定义一个Double包装类对象，值为8\n\t\tDouble d = new Double(87.0);\n        \n        // 手动拆箱\n\t\tdouble e =     d.doubleValue()          ;\n        \n        // 自动拆箱\n\t\tdouble f =     d           ;\n        \n         System.out.println(\"拆箱后的结果为：\" + e + \"和\" + f);\n\t}\n}\n```\n\n##### Java中基本类型和字符串之间的转换\n\n可以通过如下方法来进行基本类型到字符串之间的转换\n\n1. 使用包装类toString() 方法\n2. 使用String类的valueOf()方法\n3. 使用一个空字符串加上基本类型\n\n字符串转换为基本类型由以下方法\n\n1. 调用包装类的parseType() 静态方法\n2. 调用包装类的valueOf() 方法 转换为包装类，再由包装类自动转换为基本类型\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        \n\t\tdouble m = 78.5;\n\t\t//将基本类型转换为字符串\n\t\tString str1 =  String.valueOf(m);\n        String str2 =  Double.toString(m);\n        String str3 = \"\"+m;\n        \n\t\tSystem.out.println(\"m 转换为String型后与整数20的求和结果为： \"+(str1+20));\n\t\tSystem.out.println(\"m 转换为String型后与整数20的求和结果为： \"+(str2+20));\n\t\tSystem.out.println(\"m 转换为String型后与整数20的求和结果为： \"+(str3+20));\n\t\t\n\t\tString str = \"180.20\";\n\t    // 将字符串转换为基本类型\n\t\tDouble a1 =    Double.parseDouble(str);\n        Double a2 = Double.valueOf(str);\n\t\n\t\tSystem.out.println(\"str 转换为double型后与整数20的求和结果为： \"+(a2+20));\n\t\tSystem.out.println(\"str 转换为double型后与整数20的求和结果为： \"+(a2+20));\n\t}\n}\n```\n\n#### java中日期的表示\n\nDate类位于  java.util包中，主要用于获取当时的时间\n\n```java\nimport java.util.Date;\n/**\n * Created by xiejun on 2015/12/12.\n */\npublic class TestClass {\n    public static void main(String[] args) {\n        Date date = new Date();\n        System.out.println(date);\n    }\n}\n```\n\nSimpleDateFromat 类位于  java.text 包中，主要用于时间的格式化，其提供了format()方法用于时间的格式化，parse()方法用于从字符串转换为时间\n\n```java\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class TestClass {\n\n    public static void main(String[] args) throws ParseException {\n\n        // 使用format()方法将日期转换为指定格式的文本\n        SimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\");\n        SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy/MM/dd HH:mm\");\n        SimpleDateFormat sdf3 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        // 创建Date对象，表示当前时间\n        Date now = new Date();\n\n        // 调用format()方法，将日期转换为字符串并输出\n        System.out.println( sdf1.format(now)                         );\n        System.out.println(sdf2.format(now));\n        System.out.println(sdf3.format(now));\n\n        // 使用parse()方法将文本转换为日期\n        String d = \"2014-6-1 21:05:36\";\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        // 调用parse()方法，将字符串转换为日期\n        Date date = sdf.parse(d);\n\n        System.out.println(date);\n    }\n}\n```\n\nCalander 类\n\n```java\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class HelloWorld {\n    \n    public static void main(String[] args) {\n\t\t// 创建Canlendar对象\n\t\tCalendar c = Calendar.getInstance();\n        \n\t\t// 将Calendar对象转换为Date对象\n\t\tDate date = c.getTime();\n        \n\t\t// 创建SimpleDateFormat对象，指定目标格式\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        \n\t\t// 将日期转换为指定格式的字符串\n\t\tString now = sdf.format(date);\n\t\tSystem.out.println(\"当前时间：\" + now);\n\t}\n}\n```\n\n#### Math 类\n\nMath类位于java.lang 包中，包含了一些基本的数学运算方法\n\n常用方法\n\n | 返回值| 方法名|说明|\n |----|-----|\n |long|round()|返回四舍五入后的整数|\n |double|floor()|向下取整|\n |double|cell()|向上取整|\n |double|random()|[0,1）之间的随机数|\n \n更多方法参考  [oracle Math类参考文档](https://docs.oracle.com/javase/7/docs/api/java/lang/Math.html) \n \n\n\n","source":"_posts/java-commonclass.md","raw":"title: Java 学习总结四 Java中的常用类\ndate: 2015-12-8 10:17:51\ntags: [java]\n---\n\n#### Java 中的包装类\n\n为了使Java中的基本数据类型，int, float, doubtl, boolean, char等表现得跟类一样，为每个基本类型提供了一个包装类(Wrapper type)\n\n|基本类型|包装类型|\n|----|----|\n|byte|Byte|\n|short|Short|\n|int|Integer|\n|long|Long|\n|float|Float|\n|double|Double|\n|char|Character|\n|boolean|Boolean|\n\n包装类主要提供两大类方法\n\n1. 将本类型和其他基本类型进行转换\n2. 将字符串和本类型及包装类的相互转换\n\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        \n\t\t// 定义int类型变量，值为86\n\t\tint score1 = 86; \n        \n\t\t// 创建Integer包装类对象，表示变量score1的值\n\t\tInteger score2=new Integer(score1);\n        \n\t\t// 将Integer包装类转换为double类型\n\t\tdouble score3=score2.doubleValue();\n        \n\t\t// 将Integer包装类转换为float类型\n\t\tfloat score4=score2.floatValue();\n        \n\t\t// 将Integer包装类转换为int类型\n\t\tint score5 =score2.intValue();\n\n\t\tSystem.out.println(\"Integer包装类：\" + score2);\n\t\tSystem.out.println(\"double类型：\" + score3);\n\t\tSystem.out.println(\"float类型：\" + score4);\n\t\tSystem.out.println(\"int类型：\" + score5);\n\t}\n}\n```\n\n##### 包装类和基本类型的相互转换\n\n可以通过两种方式完成包装类和基本类型的换换\n\n手动转换\n\n\tWrapperType wp = new WrapperType(someBuildInType)  \n\tBuildInType  t = someWrapperType.BuildInTypeValue()\n\n自动转换\n\n\tWrapperType wp = someBuildInType;\n\tBuildInType t = someWrapperType\n\t\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        \n        // 定义double类型变量\n\t\tdouble a = 91.5;\n        \n         // 手动装箱\n\t\tDouble b =  new Double(a);      \n        \n        // 自动装箱\n\t\tDouble c =    a;   \n\n        System.out.println(\"装箱后的结果为：\" + b + \"和\" + c);\n        \n        // 定义一个Double包装类对象，值为8\n\t\tDouble d = new Double(87.0);\n        \n        // 手动拆箱\n\t\tdouble e =     d.doubleValue()          ;\n        \n        // 自动拆箱\n\t\tdouble f =     d           ;\n        \n         System.out.println(\"拆箱后的结果为：\" + e + \"和\" + f);\n\t}\n}\n```\n\n##### Java中基本类型和字符串之间的转换\n\n可以通过如下方法来进行基本类型到字符串之间的转换\n\n1. 使用包装类toString() 方法\n2. 使用String类的valueOf()方法\n3. 使用一个空字符串加上基本类型\n\n字符串转换为基本类型由以下方法\n\n1. 调用包装类的parseType() 静态方法\n2. 调用包装类的valueOf() 方法 转换为包装类，再由包装类自动转换为基本类型\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        \n\t\tdouble m = 78.5;\n\t\t//将基本类型转换为字符串\n\t\tString str1 =  String.valueOf(m);\n        String str2 =  Double.toString(m);\n        String str3 = \"\"+m;\n        \n\t\tSystem.out.println(\"m 转换为String型后与整数20的求和结果为： \"+(str1+20));\n\t\tSystem.out.println(\"m 转换为String型后与整数20的求和结果为： \"+(str2+20));\n\t\tSystem.out.println(\"m 转换为String型后与整数20的求和结果为： \"+(str3+20));\n\t\t\n\t\tString str = \"180.20\";\n\t    // 将字符串转换为基本类型\n\t\tDouble a1 =    Double.parseDouble(str);\n        Double a2 = Double.valueOf(str);\n\t\n\t\tSystem.out.println(\"str 转换为double型后与整数20的求和结果为： \"+(a2+20));\n\t\tSystem.out.println(\"str 转换为double型后与整数20的求和结果为： \"+(a2+20));\n\t}\n}\n```\n\n#### java中日期的表示\n\nDate类位于  java.util包中，主要用于获取当时的时间\n\n```java\nimport java.util.Date;\n/**\n * Created by xiejun on 2015/12/12.\n */\npublic class TestClass {\n    public static void main(String[] args) {\n        Date date = new Date();\n        System.out.println(date);\n    }\n}\n```\n\nSimpleDateFromat 类位于  java.text 包中，主要用于时间的格式化，其提供了format()方法用于时间的格式化，parse()方法用于从字符串转换为时间\n\n```java\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class TestClass {\n\n    public static void main(String[] args) throws ParseException {\n\n        // 使用format()方法将日期转换为指定格式的文本\n        SimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyy年MM月dd日 HH时mm分ss秒\");\n        SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy/MM/dd HH:mm\");\n        SimpleDateFormat sdf3 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        // 创建Date对象，表示当前时间\n        Date now = new Date();\n\n        // 调用format()方法，将日期转换为字符串并输出\n        System.out.println( sdf1.format(now)                         );\n        System.out.println(sdf2.format(now));\n        System.out.println(sdf3.format(now));\n\n        // 使用parse()方法将文本转换为日期\n        String d = \"2014-6-1 21:05:36\";\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        // 调用parse()方法，将字符串转换为日期\n        Date date = sdf.parse(d);\n\n        System.out.println(date);\n    }\n}\n```\n\nCalander 类\n\n```java\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class HelloWorld {\n    \n    public static void main(String[] args) {\n\t\t// 创建Canlendar对象\n\t\tCalendar c = Calendar.getInstance();\n        \n\t\t// 将Calendar对象转换为Date对象\n\t\tDate date = c.getTime();\n        \n\t\t// 创建SimpleDateFormat对象，指定目标格式\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        \n\t\t// 将日期转换为指定格式的字符串\n\t\tString now = sdf.format(date);\n\t\tSystem.out.println(\"当前时间：\" + now);\n\t}\n}\n```\n\n#### Math 类\n\nMath类位于java.lang 包中，包含了一些基本的数学运算方法\n\n常用方法\n\n | 返回值| 方法名|说明|\n |----|-----|\n |long|round()|返回四舍五入后的整数|\n |double|floor()|向下取整|\n |double|cell()|向上取整|\n |double|random()|[0,1）之间的随机数|\n \n更多方法参考  [oracle Math类参考文档](https://docs.oracle.com/javase/7/docs/api/java/lang/Math.html) \n \n\n\n","slug":"java-commonclass","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwbu002id6jxq97y7uqs"},{"title":"hihocoder算法练习之trie图","date":"2015-10-11T11:21:06.000Z","_content":"\n## 输入\n\n每个输入文件有且仅有一组测试数据。\n\n每个测试数据的第一行为一个整数N，表示河蟹词典的大小。\n\n接下来的N行，每一行为一个由小写英文字母组成的河蟹词语。\n\n接下来的一行，为一篇长度不超过M，由小写英文字母组成的文章。\n\n对于60%的数据，所有河蟹词语的长度总和小于10, M<=10\n\n对于80%的数据，所有河蟹词语的长度总和小于10^3, M<=10^3\n\n对于100%的数据，所有河蟹词语的长度总和小于10^6, M<=10^6, N<=1000\n\n## 输出\n\n对于每组测试数据，输出一行\"YES\"或者\"NO\"，表示文章中是否含有河蟹词语。\n\n## 样例输入\n\n\n\t6\n\taaabc\n\taaac\n\tabcc\n\tac\n\tbcd\n\tcd\n\taaaaaaaaaaabaaadaaac\n\t\n\n## 样例输出\n\n\n\tYES\n\n\n## 说明\n\n\n对于一本词典，要找一篇文章中是否含有这本词典中的词语，如果依次枚举每个词典中的每个单词，然后与文章进行匹配，如果词典单词数量是N，每个单词长度是L，文章长度为M，复杂度是O(MLN)。若采用KMP算法进行匹配，那么需要进行的次数也是O(NM).如果将词典构成trie树，枚举文章每一个单词作为起点，然后去trie树中走，如果能从某条变走到终点结点，则说明文章中存在词典中的单词，这种方式复杂度是O(ML)。\n\n我们可以发现，采用trie树这种方式是可以优化的，如下图，构造了一本字典，含有的单词是ab,bc,aba,bab,bca\n\n![](http://xiejun901.qiniudn.com/hihocoder1036trie.jpg)\n\n我们要查看abcbca是否在词典中，采用trie树来进行枚举会经历以下过程\n\n\t枚举s[0]=a;0->1;1->3;3的c边不存在；回朔\n\t枚举s[1]=b;0->b->5;5的b边不存在；回朔\n\t枚举s[2]=c;0的c边不存在；回朔\n\t枚举s[3]=b;0->2->5->8;找到两个终点借点\n\t枚举s[4]=c;0的c边不存在；回朔\n\t枚举s[5]=a;0->1；字符串完，且1不为为终点结点。\n\n考虑字符串abcac,0->1->3,此时发现1的c结点不存在，按照以上方法，则需要回朔到根结点，然后对比bcac这个字符串，过程是0->1->3=>0->2->5->8，但是1->3,b这条边已经走过了，所以最好是直接在0->1->3之后，直接跳到2结点，即：0->1->3(2)->5->8.所以，对于每一个结点，如果我们能求得它括号里边那个结点，就能大幅度优化这个算法了。括号里面那个结点，我们称之为后缀结点。\n\n对于按照 aba这样一条边走到的结点的后缀结点，应该是按照ba走到的结点，即对于s[0...n]走到的结点的后缀结点为按照s[1...n]走到的结点。对于上图有则有以下结论，next(i)表示i结点的后缀结点。\n\n\tnext(0)=0;\n\tnext(1)=0;#\"a\"去掉第一个字符为空。\n\tnext(2)=0;\n\tnext(3)=2;#\"ab\"去掉第一个字符为\"b\"\n\tnext(4)=1;#\"ba\"              \"a\"\n\tnext(5)=?;\n\t\n在计算next(5)的时候我们发现，\"bc\"去掉第一个字符\"c\",在原树中找不到，这种情况下，其实说明了以c开头的枚举都不能找到，那么我们直接跳到\"bc\"的后缀\"c\"再取后缀\" \"就行了，用结点8来举例：\n\n\t\"bca\"的后缀\"ca\",因为0的c边不存在所以直接取\"a\"， 即next(8)=1\n\n如果在\"bca\"过程中有终点结点，为了不漏掉，我们引入了“后缀结点为标记结点的结点也是标记结点”理解这一段可以参考一下[提示三：如何求解Trie树中每个结点的后缀结点](http://hihocoder.com/problemset/problem/1036) 里面有更详细的解释。（懒得画图，就不在这详细说明了。。。。。）举个例子说明一下是怎样把一颗trie树中的结点的后缀结点求出来，补充完整为空的结点构成trie图的：\n\n![trie2](http://xiejun901.qiniudn.com/hihocoder1036trie2.jpg)\n\nni,表示结点i，ni->son[a]表示结点i沿a边走的结点，ni->next表示结点i的后缀结点。\n\n\tn0->next=n0;补全不存在的边：n0->son[d]=n0;\n\tn1->next=n0;补全不存在的边：n1->son[b]=n1->next->son[b]=n2;n1->son[d]=n1->next->son[d]=n0;\n\tn2->next=n0;补全不存在的边：n2->son[a]=n2->next->son[a]=n1;......\n\tn3->next=n0;补全不存在的边：n3->son[a]=n3->next->son[a]=n1;......\n\tn4->next=n4->p->next->son[a]=n1;补全不存在的边：......\n\tn5->next=n5->p->next->son[c]=n3;补全不存在的边：......\n\t......\n\t\n算法描述如下：\n\n\t%\n\t%\n\t\nc语言实现函数如下：\n\n```c\nvoid trieSolveNext(triePtr root)\n{\n\tint i;\n\tqList queue1;\n\ttriePtr node;\n\tmemset(&queue1, 0, sizeof(queue1));\n\tnode = root;\n\tqueuePushback(&queue1, node);\n\tnode->next = node;\n\twhile (queue1.front != NULL)\n\t{\n\t\tnode = queuePopfront(&queue1);\n\t\tif (node->next->isTerminal == 1)\n\t\t\tnode->isTerminal = 1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tif (node->son[i] != NULL)\n\t\t\t{\n\t\t\t\tqueuePushback(&queue1, node->son[i]);\n\t\t\t\tif (node == root)\n\t\t\t\t\tnode->son[i]->next = node;\n\t\t\t\telse\n\t\t\t\t\tnode->son[i]->next = node->next->son[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (node == root)\n\t\t\t\t\tnode->son[i] = node;\n\t\t\t\telse\n\t\t\t\t\tnode->son[i] = node->next->son[i];\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n在构建好trie图之后，只需要从根结点开始，沿着给出的文章的字符往下走，如果走到了标记结点，则表明文章中有字典给出的单词，如果到文章走完都没遇到标记结点，那么则说明无字典中的单词\n\n```c\nint searchTrie(triePtr node, char *s)\n{\n\twhile (*s)\n\t{\n\t\tif (node->isTerminal == 1)\n\t\t\treturn 1;\n\t\tnode = node->son[*s - 'a'];\n\t\ts++;\n\t}\n\tif (node->isTerminal == 1)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n\n\n## 整体代码\n\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define N 26\ntypedef struct tnode{\n\tint isTerminal;\n\tint num;\n\tstruct tnode *p;\n\tstruct tnode * son[N];\n\tstruct tnode *next;\n} trieNode;\ntypedef trieNode *triePtr;\ntypedef struct qnode{\n\ttriePtr key;\n\tstruct qnode * next;\n} qNode;\ntypedef qNode *qPtr;\ntypedef struct qlist{\n\tqPtr front, back;\n} qList;\ntypedef qList *qListPtr;\ntriePtr trieInsert(triePtr node, char * s);\nint prefixCount(triePtr node, char *s);\nvoid queuePushback(qListPtr q, triePtr key);\ntriePtr queuePopfront(qListPtr q);\nvoid trieBfs(triePtr node);\nvoid trieSolveNext(triePtr root);\nint searchTrie(triePtr node, char *s);\nint main()\n{\n\tint m;\n\tchar s[100];\n\tint temp;\n\ttriePtr root = NULL;\n\troot = (triePtr)malloc(sizeof(trieNode));\n\tmemset(root, 0, sizeof(trieNode));\n\t//trieInsert(root, \"aaabc\");\n\t//trieInsert(root, \"aaac\");\n\t//trieInsert(root, \"abcc\");\n\t//trieInsert(root, \"ac\");\n\t//trieInsert(root, \"bcd\");\n\t//trieInsert(root, \"cd\");\n\tscanf(\"%d\", &m);\n\twhile (m--)\n\t{\n\t\tscanf(\"%s\", s);\n\t\ttrieInsert(root, s);\n\t}\n\tscanf(\"%s\", s);\n\t//trieBfs(root);\n\ttrieSolveNext(root);\n\ttemp = searchTrie(root, s);\n\tif (temp == 1)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}\n\ntriePtr trieInsert(triePtr node, char * s)\n{\n\ttriePtr newNode;\n\t//\tint i;\n\twhile (*s)\n\t{\n\t\tif (node->son[*s - 'a'] == NULL)\n\t\t{\n\t\t\tnewNode = (triePtr)malloc(sizeof(trieNode));\n\t\t\tmemset(newNode, 0, sizeof(trieNode));\n\t\t\tnewNode->p = node;\n\t\t\tnode->son[*s - 'a'] = newNode;\n\t\t}\n\t\tnode = node->son[*s - 'a'];\n\t\tnode->num++;\n\t\ts++;\n\t}\n\tnode->isTerminal = 1;\n\treturn node;\n}\n\nint prefixCount(triePtr node, char *s)\n{\n\twhile (*s)\n\t{\n\t\tif (node->son[*s - 'a'] == NULL)\n\t\t\treturn 0;\n\t\tnode = node->son[*s - 'a'];\n\t\ts++;\n\t}\n\treturn node->num;\n}\n\nvoid queuePushback(qListPtr q, triePtr key)\n{\n\tqPtr newPtr;\n\tnewPtr = (qPtr)malloc(sizeof(qNode));\n\tnewPtr->key = key;\n\tnewPtr->next = NULL;\n\tif ((*q).front == NULL)\n\t{\n\t\t(*q).front = (*q).back = newPtr;\n\t}\n\telse\n\t{\n\t\t(*q).back->next = newPtr;\n\t\t(*q).back = newPtr;\n\t}\n}\n\ntriePtr queuePopfront(qListPtr q)\n{\n\ttriePtr newPtr;\n\tqPtr tempPtr;\n\tnewPtr = (*q).front->key;\n\ttempPtr = (*q).front;\n\t(*q).front = tempPtr->next;\n\tfree(tempPtr);\n\treturn newPtr;\n}\n\nvoid trieBfs(triePtr node)\n{\n\tint i;\n\tqList queue1;\n\tmemset(&queue1, 0, sizeof(queue1));\n\tqueuePushback(&queue1, node);\n\twhile (queue1.front != NULL)\n\t{\n\t\tnode = queuePopfront(&queue1);\n\t\tprintf(\"%p\\n\", node);\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tif (node->son[i] != NULL)\n\t\t\t{\n\t\t\t\tqueuePushback(&queue1, node->son[i]);\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nvoid trieSolveNext(triePtr root)\n{\n\tint i;\n\tqList queue1;\n\ttriePtr node;\n\tmemset(&queue1, 0, sizeof(queue1));\n\tnode = root;\n\tqueuePushback(&queue1, node);\n\tnode->next = node;\n\twhile (queue1.front != NULL)\n\t{\n\t\tnode = queuePopfront(&queue1);\n\t\tif (node->next->isTerminal == 1)\n\t\t\tnode->isTerminal = 1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tif (node->son[i] != NULL)\n\t\t\t{\n\t\t\t\tqueuePushback(&queue1, node->son[i]);\n\t\t\t\tif (node == root)\n\t\t\t\t\tnode->son[i]->next = node;\n\t\t\t\telse\n\t\t\t\t\tnode->son[i]->next = node->next->son[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (node == root)\n\t\t\t\t\tnode->son[i] = node;\n\t\t\t\telse\n\t\t\t\t\tnode->son[i] = node->next->son[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint searchTrie(triePtr node, char *s)\n{\n\twhile (*s)\n\t{\n\t\tif (node->isTerminal == 1)\n\t\t\treturn 1;\n\t\tnode = node->son[*s - 'a'];\n\t\ts++;\n\t}\n\tif (node->isTerminal == 1)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n","source":"_posts/hihocoder-trie2.md","raw":"title: hihocoder算法练习之trie图\ndate: 2015-10-11 19:21:06\ntags: [hihocoder, algorithm, c++, trie图]\ncategories: hihocoder\n---\n\n## 输入\n\n每个输入文件有且仅有一组测试数据。\n\n每个测试数据的第一行为一个整数N，表示河蟹词典的大小。\n\n接下来的N行，每一行为一个由小写英文字母组成的河蟹词语。\n\n接下来的一行，为一篇长度不超过M，由小写英文字母组成的文章。\n\n对于60%的数据，所有河蟹词语的长度总和小于10, M<=10\n\n对于80%的数据，所有河蟹词语的长度总和小于10^3, M<=10^3\n\n对于100%的数据，所有河蟹词语的长度总和小于10^6, M<=10^6, N<=1000\n\n## 输出\n\n对于每组测试数据，输出一行\"YES\"或者\"NO\"，表示文章中是否含有河蟹词语。\n\n## 样例输入\n\n\n\t6\n\taaabc\n\taaac\n\tabcc\n\tac\n\tbcd\n\tcd\n\taaaaaaaaaaabaaadaaac\n\t\n\n## 样例输出\n\n\n\tYES\n\n\n## 说明\n\n\n对于一本词典，要找一篇文章中是否含有这本词典中的词语，如果依次枚举每个词典中的每个单词，然后与文章进行匹配，如果词典单词数量是N，每个单词长度是L，文章长度为M，复杂度是O(MLN)。若采用KMP算法进行匹配，那么需要进行的次数也是O(NM).如果将词典构成trie树，枚举文章每一个单词作为起点，然后去trie树中走，如果能从某条变走到终点结点，则说明文章中存在词典中的单词，这种方式复杂度是O(ML)。\n\n我们可以发现，采用trie树这种方式是可以优化的，如下图，构造了一本字典，含有的单词是ab,bc,aba,bab,bca\n\n![](http://xiejun901.qiniudn.com/hihocoder1036trie.jpg)\n\n我们要查看abcbca是否在词典中，采用trie树来进行枚举会经历以下过程\n\n\t枚举s[0]=a;0->1;1->3;3的c边不存在；回朔\n\t枚举s[1]=b;0->b->5;5的b边不存在；回朔\n\t枚举s[2]=c;0的c边不存在；回朔\n\t枚举s[3]=b;0->2->5->8;找到两个终点借点\n\t枚举s[4]=c;0的c边不存在；回朔\n\t枚举s[5]=a;0->1；字符串完，且1不为为终点结点。\n\n考虑字符串abcac,0->1->3,此时发现1的c结点不存在，按照以上方法，则需要回朔到根结点，然后对比bcac这个字符串，过程是0->1->3=>0->2->5->8，但是1->3,b这条边已经走过了，所以最好是直接在0->1->3之后，直接跳到2结点，即：0->1->3(2)->5->8.所以，对于每一个结点，如果我们能求得它括号里边那个结点，就能大幅度优化这个算法了。括号里面那个结点，我们称之为后缀结点。\n\n对于按照 aba这样一条边走到的结点的后缀结点，应该是按照ba走到的结点，即对于s[0...n]走到的结点的后缀结点为按照s[1...n]走到的结点。对于上图有则有以下结论，next(i)表示i结点的后缀结点。\n\n\tnext(0)=0;\n\tnext(1)=0;#\"a\"去掉第一个字符为空。\n\tnext(2)=0;\n\tnext(3)=2;#\"ab\"去掉第一个字符为\"b\"\n\tnext(4)=1;#\"ba\"              \"a\"\n\tnext(5)=?;\n\t\n在计算next(5)的时候我们发现，\"bc\"去掉第一个字符\"c\",在原树中找不到，这种情况下，其实说明了以c开头的枚举都不能找到，那么我们直接跳到\"bc\"的后缀\"c\"再取后缀\" \"就行了，用结点8来举例：\n\n\t\"bca\"的后缀\"ca\",因为0的c边不存在所以直接取\"a\"， 即next(8)=1\n\n如果在\"bca\"过程中有终点结点，为了不漏掉，我们引入了“后缀结点为标记结点的结点也是标记结点”理解这一段可以参考一下[提示三：如何求解Trie树中每个结点的后缀结点](http://hihocoder.com/problemset/problem/1036) 里面有更详细的解释。（懒得画图，就不在这详细说明了。。。。。）举个例子说明一下是怎样把一颗trie树中的结点的后缀结点求出来，补充完整为空的结点构成trie图的：\n\n![trie2](http://xiejun901.qiniudn.com/hihocoder1036trie2.jpg)\n\nni,表示结点i，ni->son[a]表示结点i沿a边走的结点，ni->next表示结点i的后缀结点。\n\n\tn0->next=n0;补全不存在的边：n0->son[d]=n0;\n\tn1->next=n0;补全不存在的边：n1->son[b]=n1->next->son[b]=n2;n1->son[d]=n1->next->son[d]=n0;\n\tn2->next=n0;补全不存在的边：n2->son[a]=n2->next->son[a]=n1;......\n\tn3->next=n0;补全不存在的边：n3->son[a]=n3->next->son[a]=n1;......\n\tn4->next=n4->p->next->son[a]=n1;补全不存在的边：......\n\tn5->next=n5->p->next->son[c]=n3;补全不存在的边：......\n\t......\n\t\n算法描述如下：\n\n\t%\n\t%\n\t\nc语言实现函数如下：\n\n```c\nvoid trieSolveNext(triePtr root)\n{\n\tint i;\n\tqList queue1;\n\ttriePtr node;\n\tmemset(&queue1, 0, sizeof(queue1));\n\tnode = root;\n\tqueuePushback(&queue1, node);\n\tnode->next = node;\n\twhile (queue1.front != NULL)\n\t{\n\t\tnode = queuePopfront(&queue1);\n\t\tif (node->next->isTerminal == 1)\n\t\t\tnode->isTerminal = 1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tif (node->son[i] != NULL)\n\t\t\t{\n\t\t\t\tqueuePushback(&queue1, node->son[i]);\n\t\t\t\tif (node == root)\n\t\t\t\t\tnode->son[i]->next = node;\n\t\t\t\telse\n\t\t\t\t\tnode->son[i]->next = node->next->son[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (node == root)\n\t\t\t\t\tnode->son[i] = node;\n\t\t\t\telse\n\t\t\t\t\tnode->son[i] = node->next->son[i];\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n在构建好trie图之后，只需要从根结点开始，沿着给出的文章的字符往下走，如果走到了标记结点，则表明文章中有字典给出的单词，如果到文章走完都没遇到标记结点，那么则说明无字典中的单词\n\n```c\nint searchTrie(triePtr node, char *s)\n{\n\twhile (*s)\n\t{\n\t\tif (node->isTerminal == 1)\n\t\t\treturn 1;\n\t\tnode = node->son[*s - 'a'];\n\t\ts++;\n\t}\n\tif (node->isTerminal == 1)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n\n\n## 整体代码\n\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define N 26\ntypedef struct tnode{\n\tint isTerminal;\n\tint num;\n\tstruct tnode *p;\n\tstruct tnode * son[N];\n\tstruct tnode *next;\n} trieNode;\ntypedef trieNode *triePtr;\ntypedef struct qnode{\n\ttriePtr key;\n\tstruct qnode * next;\n} qNode;\ntypedef qNode *qPtr;\ntypedef struct qlist{\n\tqPtr front, back;\n} qList;\ntypedef qList *qListPtr;\ntriePtr trieInsert(triePtr node, char * s);\nint prefixCount(triePtr node, char *s);\nvoid queuePushback(qListPtr q, triePtr key);\ntriePtr queuePopfront(qListPtr q);\nvoid trieBfs(triePtr node);\nvoid trieSolveNext(triePtr root);\nint searchTrie(triePtr node, char *s);\nint main()\n{\n\tint m;\n\tchar s[100];\n\tint temp;\n\ttriePtr root = NULL;\n\troot = (triePtr)malloc(sizeof(trieNode));\n\tmemset(root, 0, sizeof(trieNode));\n\t//trieInsert(root, \"aaabc\");\n\t//trieInsert(root, \"aaac\");\n\t//trieInsert(root, \"abcc\");\n\t//trieInsert(root, \"ac\");\n\t//trieInsert(root, \"bcd\");\n\t//trieInsert(root, \"cd\");\n\tscanf(\"%d\", &m);\n\twhile (m--)\n\t{\n\t\tscanf(\"%s\", s);\n\t\ttrieInsert(root, s);\n\t}\n\tscanf(\"%s\", s);\n\t//trieBfs(root);\n\ttrieSolveNext(root);\n\ttemp = searchTrie(root, s);\n\tif (temp == 1)\n\t\tprintf(\"YES\");\n\telse\n\t\tprintf(\"NO\");\n\treturn 0;\n}\n\ntriePtr trieInsert(triePtr node, char * s)\n{\n\ttriePtr newNode;\n\t//\tint i;\n\twhile (*s)\n\t{\n\t\tif (node->son[*s - 'a'] == NULL)\n\t\t{\n\t\t\tnewNode = (triePtr)malloc(sizeof(trieNode));\n\t\t\tmemset(newNode, 0, sizeof(trieNode));\n\t\t\tnewNode->p = node;\n\t\t\tnode->son[*s - 'a'] = newNode;\n\t\t}\n\t\tnode = node->son[*s - 'a'];\n\t\tnode->num++;\n\t\ts++;\n\t}\n\tnode->isTerminal = 1;\n\treturn node;\n}\n\nint prefixCount(triePtr node, char *s)\n{\n\twhile (*s)\n\t{\n\t\tif (node->son[*s - 'a'] == NULL)\n\t\t\treturn 0;\n\t\tnode = node->son[*s - 'a'];\n\t\ts++;\n\t}\n\treturn node->num;\n}\n\nvoid queuePushback(qListPtr q, triePtr key)\n{\n\tqPtr newPtr;\n\tnewPtr = (qPtr)malloc(sizeof(qNode));\n\tnewPtr->key = key;\n\tnewPtr->next = NULL;\n\tif ((*q).front == NULL)\n\t{\n\t\t(*q).front = (*q).back = newPtr;\n\t}\n\telse\n\t{\n\t\t(*q).back->next = newPtr;\n\t\t(*q).back = newPtr;\n\t}\n}\n\ntriePtr queuePopfront(qListPtr q)\n{\n\ttriePtr newPtr;\n\tqPtr tempPtr;\n\tnewPtr = (*q).front->key;\n\ttempPtr = (*q).front;\n\t(*q).front = tempPtr->next;\n\tfree(tempPtr);\n\treturn newPtr;\n}\n\nvoid trieBfs(triePtr node)\n{\n\tint i;\n\tqList queue1;\n\tmemset(&queue1, 0, sizeof(queue1));\n\tqueuePushback(&queue1, node);\n\twhile (queue1.front != NULL)\n\t{\n\t\tnode = queuePopfront(&queue1);\n\t\tprintf(\"%p\\n\", node);\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tif (node->son[i] != NULL)\n\t\t\t{\n\t\t\t\tqueuePushback(&queue1, node->son[i]);\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nvoid trieSolveNext(triePtr root)\n{\n\tint i;\n\tqList queue1;\n\ttriePtr node;\n\tmemset(&queue1, 0, sizeof(queue1));\n\tnode = root;\n\tqueuePushback(&queue1, node);\n\tnode->next = node;\n\twhile (queue1.front != NULL)\n\t{\n\t\tnode = queuePopfront(&queue1);\n\t\tif (node->next->isTerminal == 1)\n\t\t\tnode->isTerminal = 1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tif (node->son[i] != NULL)\n\t\t\t{\n\t\t\t\tqueuePushback(&queue1, node->son[i]);\n\t\t\t\tif (node == root)\n\t\t\t\t\tnode->son[i]->next = node;\n\t\t\t\telse\n\t\t\t\t\tnode->son[i]->next = node->next->son[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (node == root)\n\t\t\t\t\tnode->son[i] = node;\n\t\t\t\telse\n\t\t\t\t\tnode->son[i] = node->next->son[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint searchTrie(triePtr node, char *s)\n{\n\twhile (*s)\n\t{\n\t\tif (node->isTerminal == 1)\n\t\t\treturn 1;\n\t\tnode = node->son[*s - 'a'];\n\t\ts++;\n\t}\n\tif (node->isTerminal == 1)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n","slug":"hihocoder-trie2","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwby002kd6jxw411rrbz"},{"title":"hihocoder算法练习之trie树","date":"2015-10-11T04:07:05.000Z","_content":"\n## 输入\n\n输入的第一行为一个正整数n，表示词典的大小，其后n行，每一行一个单词（不保证是英文单词，也有可能是火星文单词哦），单词由不超过10个的小写英文字母组成，可能存在相同的单词，此时应将其视作不同的单词。接下来的一行为一个正整数m，表示询问的次数，其后m行，每一行一个字符串，该字符串由不超过10个的小写英文字母组成，表示一个询问。\n\n\n## 输出\n\n对于每一个询问，输出一个整数Ans,表示词典中以询问给出的字符串为前缀的单词的个数。\n\n\n## 样例输入\n\n\t\n\t5\n\tbabaab\n\tbabbbaaaa\n\tabba\n\taaaaabaa\n\tbabaababb\n\t5\n\tbabb\n\tbaabaaa\n\tbab\n\tbb\n\tbbabbaab\n\t\n\n## 样例输出\n\n\t\n\t1\n\t0\n\t3\n\t0\n\t0\n\n\n## 代码\n\n\t\n```cpp\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\ntypedef struct trie_node{\n\tint m;\n\ttrie_node * next[26];\n} trie_node;\nint main()\n{\n\ttrie_node * root=new trie_node;\n\ttrie_node * current;\n\ttrie_node * newnode;\n\tint n;\n\tint i;\n\tint flag=0;\n\tstring s1;\n\tmemset(root->next, 0, sizeof(root->next));\n\troot->m = 1;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcurrent = root;\n\t\tcin >> s1;\n\t\tfor (i = 0; i < s1.length(); i++)\n\t\t{\n\t\t\tif (current->next[s1[i] - 'a'] == NULL)\n\t\t\t{\n\t\t\t\tnewnode = new trie_node;\n\t\t\t\tmemset(newnode->next, 0, sizeof(newnode->next));\n\t\t\t\tnewnode->m = 1;\n\t\t\t\tcurrent->next[s1[i] - 'a'] = newnode;\n\t\t\t}\n\t\t\telse\n\t\t\t\t((current->next[s1[i] - 'a'])->m)++;\n\t\t\tcurrent = current->next[s1[i] - 'a'];\n\t\t}\n\t}\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcurrent = root;\n\t\tflag = 0;\n\t\tcin >> s1;\n\t\tfor (i = 0; i < s1.length(); i++)\n\t\t{\n\t\t\tif (current->next[s1[i] - 'a'] == NULL)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcurrent = current->next[s1[i] - 'a'];\n\t\t}\n\t\tif (flag)\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << current->m << endl;\n\n\t}\n}\n```","source":"_posts/hihocoder-trie.md","raw":"title: hihocoder算法练习之trie树\ndate: 2015-10-11 12:07:05\ntags : [hihocoder, algorithm, c++, trie树, 字典树]\ncategories: hihocoder\n---\n\n## 输入\n\n输入的第一行为一个正整数n，表示词典的大小，其后n行，每一行一个单词（不保证是英文单词，也有可能是火星文单词哦），单词由不超过10个的小写英文字母组成，可能存在相同的单词，此时应将其视作不同的单词。接下来的一行为一个正整数m，表示询问的次数，其后m行，每一行一个字符串，该字符串由不超过10个的小写英文字母组成，表示一个询问。\n\n\n## 输出\n\n对于每一个询问，输出一个整数Ans,表示词典中以询问给出的字符串为前缀的单词的个数。\n\n\n## 样例输入\n\n\t\n\t5\n\tbabaab\n\tbabbbaaaa\n\tabba\n\taaaaabaa\n\tbabaababb\n\t5\n\tbabb\n\tbaabaaa\n\tbab\n\tbb\n\tbbabbaab\n\t\n\n## 样例输出\n\n\t\n\t1\n\t0\n\t3\n\t0\n\t0\n\n\n## 代码\n\n\t\n```cpp\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\ntypedef struct trie_node{\n\tint m;\n\ttrie_node * next[26];\n} trie_node;\nint main()\n{\n\ttrie_node * root=new trie_node;\n\ttrie_node * current;\n\ttrie_node * newnode;\n\tint n;\n\tint i;\n\tint flag=0;\n\tstring s1;\n\tmemset(root->next, 0, sizeof(root->next));\n\troot->m = 1;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcurrent = root;\n\t\tcin >> s1;\n\t\tfor (i = 0; i < s1.length(); i++)\n\t\t{\n\t\t\tif (current->next[s1[i] - 'a'] == NULL)\n\t\t\t{\n\t\t\t\tnewnode = new trie_node;\n\t\t\t\tmemset(newnode->next, 0, sizeof(newnode->next));\n\t\t\t\tnewnode->m = 1;\n\t\t\t\tcurrent->next[s1[i] - 'a'] = newnode;\n\t\t\t}\n\t\t\telse\n\t\t\t\t((current->next[s1[i] - 'a'])->m)++;\n\t\t\tcurrent = current->next[s1[i] - 'a'];\n\t\t}\n\t}\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcurrent = root;\n\t\tflag = 0;\n\t\tcin >> s1;\n\t\tfor (i = 0; i < s1.length(); i++)\n\t\t{\n\t\t\tif (current->next[s1[i] - 'a'] == NULL)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcurrent = current->next[s1[i] - 'a'];\n\t\t}\n\t\tif (flag)\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << current->m << endl;\n\n\t}\n}\n```","slug":"hihocoder-trie","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwc2002ud6jxa48wfa49"},{"title":"hihocoder算法练习之kmp算法","date":"2015-10-11T07:53:09.000Z","_content":"\n## 输入\n\n第一行一个整数N，表示测试数据组数。接下来的N*2行，每两行表示一个测试数据。在每一个测试数据中，第一行为模式串，由不超过10^4个大写字母组成，第二行为原串，由不超过10^6个大写字母组成。其中N<=20\n\n## 输出\n\n对于每一个测试数据，按照它们在输入中出现的顺序输出一行Ans，表示模式串在原串中出现的次数。\n\n## 样例输入\n\n\t\n\t5\n\tHA\n\tHAHAHA\n\tWQN\n\tWQN\n\tADA\n\tADADADA\n\tBABABB\n\tBABABABABABABABABB\n\tDAD\n\tADDAADAADDAAADAAD\n\t\n## 样例输出\n\n\t\n\t3\n\t1\n\t3\n\t1\n\t0\n\n## 说明\n\n\n判断给出的一串字符串（原串）中是否含有特定的字符串（模式串），对于原串s=\"bababababababababb\"，模式串p=\"bababb\"，按照最普通的匹配方法\n\n当匹配到i=5,j=5时候无法匹配\n\t\n\tb a b a b a b a b a b a b a b a b b\n\tb a b a b b\n\t\n此时需要使i=1,j=0;\n\t\n\tb a b a b a b a b a b a b a b a b b\n\t  b a b a b b\n\t  \n继续失配一直到i=2,j=0又能继续搭配上：\n\t\t\n\tb a b a b a b a b a b a b a b a b b\n\t    b a b a b b\n\t  \n我们可以观察到p0p1p2==p2p3p4;所以当匹配到i=5,j=5失配时，因为这个时候有p0p1p2p3p4=s0s1s2s3s4,所以此时应该用p0去与s2对齐进行匹配，即在i=5,j=5之后下一个需要匹配的是i=5,j=3;\n\t\n\tb a b a b a b a b a b a b a b a b b\n\t    b a b a b b\n\t\t\n即在匹配到失配时，i保持不变等于5，j取\"p0p1p2p3p4\"前缀与后缀相等的最长长度，3。 对于字符串\"bababb\"有：next[4]==3;\n\n## KMP算法\n\n\t首先对字符串进行匹配，在原串的位置i，模式串的位置j,发现失配了。此时i保持不变，j=next[j-1],由nex数组性质可以得到p0p1...p[j-1]是跟原串能完全匹配上的，所以只需要继续匹配p[j]与s[i]即行.\n\t\n## next数组求解\n\n求解next数组可以采用递归的方法，对于\"bababb\"，\n\t\n\ti=1,j=0;\n\tb a b a\n\t  b\n\t不等且j=0;因此next[1]=0;然后继续求解下一个next\n\ti=2,j=0;\n\tb a b a \n\t    b\n\t匹配上了，j++,next[2]=j=1;继续求解下一个next\n\ti=3,j=1;\n\tb a b a b b\n\t    b a\n\t匹配上了，j++,next[3]=j=2;继续求解下一个next\n\ti=4,j=2;\n\tb a b a b b\n\t    b a b\n\t匹配上了，j++,next[3]=j=3;继续求解下一个next\n\ti=5,j=3;\n\tb a b a b b\n\t    b a b a \n\t失配，j=next[j-1]=1,继续匹配\n\tb a b a b b \n\t        b a\n\t失配，j=next[j-1]=0,继续匹配 \n\tb a b a b b\n\t          b\n\t匹配上了，j++，next[5]=1。(这儿如果是匹配不上的话，因为j=0，所以会直接得到next[5]=0)\n\t\n以上为一个求解过程的示例\n\n\n## 代码\n\n\t\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid getnext(string s, int * next);\nint main()\n{\n\tstring s;\n\tstring p;\n\tint n;\n\tint i, j, count;\n\tcin>>n;\n\twhile (n--)\n\t{\n\t\tcin >> p >> s;\n\t\tint * next = new int[p.length()];\n\t\tgetnext(p, next);\n\t\ti = 0;\n\t\tj = 0;\n\t\tcount = 0;\n\t\twhile (i < s.length())\n\t\t{\n\t\t\twhile (j != 0 && s[i] != p[j])\n\t\t\t{\n\t\t\t\tj = next[j - 1];\n\t\t\t}\n\t\t\tif (s[i] == p[j])\n\t\t\t{\n\t\t\t\tif (j == p.length() - 1)\n\t\t\t\t{\n\t\t\t\t\tj = next[j]; \n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tcout << count << endl;\n\n\n\t}\n\treturn 0;\n\n\n}\nvoid getnext(string s, int * next)\n{\n\n\tnext[0] = 0;\n\tint i = 1;\n\tint j = 0;\n\twhile (i < s.length())\n\t{\n\t\twhile ((j != 0) && (s[i] != s[j]))\n\t\t\tj = next[j-1];\n\t\tif (s[i] == s[j])\n\t\t\tj++;\n\t\tnext[i] = j;\n\t\ti++;\n\t}\n\n}\n```\n","source":"_posts/hihocoder-kmp.md","raw":"title: hihocoder算法练习之kmp算法\ndate: 2015-10-11 15:53:09\ntags: [hihocoder, algorithm, c++, kmp, next数组]\ncategories: hihocoder\n---\n\n## 输入\n\n第一行一个整数N，表示测试数据组数。接下来的N*2行，每两行表示一个测试数据。在每一个测试数据中，第一行为模式串，由不超过10^4个大写字母组成，第二行为原串，由不超过10^6个大写字母组成。其中N<=20\n\n## 输出\n\n对于每一个测试数据，按照它们在输入中出现的顺序输出一行Ans，表示模式串在原串中出现的次数。\n\n## 样例输入\n\n\t\n\t5\n\tHA\n\tHAHAHA\n\tWQN\n\tWQN\n\tADA\n\tADADADA\n\tBABABB\n\tBABABABABABABABABB\n\tDAD\n\tADDAADAADDAAADAAD\n\t\n## 样例输出\n\n\t\n\t3\n\t1\n\t3\n\t1\n\t0\n\n## 说明\n\n\n判断给出的一串字符串（原串）中是否含有特定的字符串（模式串），对于原串s=\"bababababababababb\"，模式串p=\"bababb\"，按照最普通的匹配方法\n\n当匹配到i=5,j=5时候无法匹配\n\t\n\tb a b a b a b a b a b a b a b a b b\n\tb a b a b b\n\t\n此时需要使i=1,j=0;\n\t\n\tb a b a b a b a b a b a b a b a b b\n\t  b a b a b b\n\t  \n继续失配一直到i=2,j=0又能继续搭配上：\n\t\t\n\tb a b a b a b a b a b a b a b a b b\n\t    b a b a b b\n\t  \n我们可以观察到p0p1p2==p2p3p4;所以当匹配到i=5,j=5失配时，因为这个时候有p0p1p2p3p4=s0s1s2s3s4,所以此时应该用p0去与s2对齐进行匹配，即在i=5,j=5之后下一个需要匹配的是i=5,j=3;\n\t\n\tb a b a b a b a b a b a b a b a b b\n\t    b a b a b b\n\t\t\n即在匹配到失配时，i保持不变等于5，j取\"p0p1p2p3p4\"前缀与后缀相等的最长长度，3。 对于字符串\"bababb\"有：next[4]==3;\n\n## KMP算法\n\n\t首先对字符串进行匹配，在原串的位置i，模式串的位置j,发现失配了。此时i保持不变，j=next[j-1],由nex数组性质可以得到p0p1...p[j-1]是跟原串能完全匹配上的，所以只需要继续匹配p[j]与s[i]即行.\n\t\n## next数组求解\n\n求解next数组可以采用递归的方法，对于\"bababb\"，\n\t\n\ti=1,j=0;\n\tb a b a\n\t  b\n\t不等且j=0;因此next[1]=0;然后继续求解下一个next\n\ti=2,j=0;\n\tb a b a \n\t    b\n\t匹配上了，j++,next[2]=j=1;继续求解下一个next\n\ti=3,j=1;\n\tb a b a b b\n\t    b a\n\t匹配上了，j++,next[3]=j=2;继续求解下一个next\n\ti=4,j=2;\n\tb a b a b b\n\t    b a b\n\t匹配上了，j++,next[3]=j=3;继续求解下一个next\n\ti=5,j=3;\n\tb a b a b b\n\t    b a b a \n\t失配，j=next[j-1]=1,继续匹配\n\tb a b a b b \n\t        b a\n\t失配，j=next[j-1]=0,继续匹配 \n\tb a b a b b\n\t          b\n\t匹配上了，j++，next[5]=1。(这儿如果是匹配不上的话，因为j=0，所以会直接得到next[5]=0)\n\t\n以上为一个求解过程的示例\n\n\n## 代码\n\n\t\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid getnext(string s, int * next);\nint main()\n{\n\tstring s;\n\tstring p;\n\tint n;\n\tint i, j, count;\n\tcin>>n;\n\twhile (n--)\n\t{\n\t\tcin >> p >> s;\n\t\tint * next = new int[p.length()];\n\t\tgetnext(p, next);\n\t\ti = 0;\n\t\tj = 0;\n\t\tcount = 0;\n\t\twhile (i < s.length())\n\t\t{\n\t\t\twhile (j != 0 && s[i] != p[j])\n\t\t\t{\n\t\t\t\tj = next[j - 1];\n\t\t\t}\n\t\t\tif (s[i] == p[j])\n\t\t\t{\n\t\t\t\tif (j == p.length() - 1)\n\t\t\t\t{\n\t\t\t\t\tj = next[j]; \n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tcout << count << endl;\n\n\n\t}\n\treturn 0;\n\n\n}\nvoid getnext(string s, int * next)\n{\n\n\tnext[0] = 0;\n\tint i = 1;\n\tint j = 0;\n\twhile (i < s.length())\n\t{\n\t\twhile ((j != 0) && (s[i] != s[j]))\n\t\t\tj = next[j-1];\n\t\tif (s[i] == s[j])\n\t\t\tj++;\n\t\tnext[i] = j;\n\t\ti++;\n\t}\n\n}\n```\n","slug":"hihocoder-kmp","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwc70033d6jxjagae4mi"},{"title":"hihocoder算法练习之二分图","date":"2015-10-11T11:31:05.000Z","_content":"\n# 二分图判定\n\n\n## 输入\n\n第1行：1个正整数T(1≤T≤10)\n接下来T组数据，每组数据按照以下格式给出：\n第1行：2个正整数N,M(1≤N≤10,000，1≤M≤40,000)\n第2..M+1行：每行两个整数u,v表示u和v之间有一条边\n\n\n## 输出\n\n\n第1..T行：第i行表示第i组数据是否有误。如果是正确的数据输出”Correct”，否则输出”Wrong”\n\n## 样例输入\n\n\n\t2\n\t5 5\n\t1 2\n\t1 3\n\t3 4\n\t5 2\n\t1 5\n\t5 5\n\t1 2\n\t1 3\n\t3 4\n\t5 2\n\t3 5\n\n\n## 样例输出\n\n\n\tWrong\n\tCorrect\n\n## 说明\n\n\n根据输入生成图，然后按照bfs或者dfs对顶点进行着，如果相邻的两个顶点为相同颜色，则判定不为二分图，注意数据中的非连通图。\n\n\n## 代码\n\n\n```\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#define M 40000\n#define N 10000\n#define gray 0\n#define black 1\n#define white -1\nint bfsGraph(int(&vertex)[N + 1], std::vector<int>(&vec)[N + 1], int k);\nint main()\n{\n\tint t;\n\tstd::cin >> t;\n\twhile (t--)\n\t{\n\t\tint n, m;\n\t\tint u, v;\n\t\tint flag = 1;\n\t\tstd::vector<int> vec[N + 1];\n\t\tint vertex[N + 1];\n\t\tstd::memset(vertex,0,sizeof(vertex));\n\t\tstd::cin >> n >> m;\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tstd::cin >> u >> v;\n\t\t\tvec[u].push_back(v);\n\t\t\tvec[v].push_back(u);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (vertex[i] == gray)\n\t\t\t{\n\t\t\t\tif (!bfsGraph(vertex, vec, i))\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t\tstd::cout << \"Correct\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"Wrong\" << std::endl;\n\t}\n\treturn 0;\n}\nint bfsGraph(int (&vertex)[N + 1], std::vector<int> (&vec)[N + 1],int k)\n{\n\tstd::stack<int> s;\n\tint index=k;\n\tvertex[index] = black;\n\ts.push(index);\n\twhile (!s.empty())\n\t{\n\t\tindex = s.top();\n\t\ts.pop();\n\t\tfor (std::vector<int>::iterator iter = vec[index].begin(); iter != vec[index].end(); ++iter)\n\t\t{\n\t\t\tif (vertex[*iter] == gray)\n\t\t\t{\n\t\t\t\tvertex[*iter] = 0 - vertex[index];\n\t\t\t\ts.push(*iter);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (vertex[*iter] + vertex[index] != 0)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n```\n\n# 二分图--最大匹配\n\n\n## 描述\n\n\n给定一个二分图G，在G的一个子图M中，M的边集中的任何两天边都不依附于同一个顶点，则称M是一个匹配，选择这样的子集中边数最大的子集称为图的最大匹配问题\n\n增光路(增广轨，交错轨)：P（增光轨）的顶点为未匹配点，属于M的边和不属于M的边在P上交错出现。\n\n匈牙利算法：找到增广路，并将增广路置反，每进行一次可以使M的匹配书加1\n\n如果所示：\n\n![](http://xiejun901.qiniudn.com/hihocoder二分图最大匹配.jpg)\n\n![](http://xiejun901.qiniudn.com/hihocoder二分图最大匹配2.jpg)\n\n如上图，在对点5进行判断时，发现点5‘已经于点4连接，此时我们需要递归对点4进行增广轨判断，如果点4的增光轨存在，我们需要将5-5’加入M，5’-4从M中去掉。递归会一直持续到判断点1，可以发现与点1相连的点1’未被匹配，因此结束递归。\n\n伪代码：\n\t\n\tfinpath(u)\n\t\tfor v connect u\n\t\t\tif(v未被访问过)\n\t\t\t\tv置访问\n\t\t\t\tif(v未被匹配 || findpath(v))\n\t\t\t\t\t将u-v加入M\n\t\t\t\t\treturn 1\n\t\treturn 0；\n\n\n\n## 完整代码\n\n\n```\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#define N 10+1\n#define M 10+1\n#define gray 0\n#define black 1\n#define white 0\nusing namespace std;\nint vertex[N] = { 0 };\nint match[N] = { 0 };\nint visit[N] = { 0 };\nvector<int> adjList[N];\nint n, m;\nvoid insertSide(int u, int v);\nvoid drawColor();\nint findPath(int u);\nint main()\n{\n\tcin >> n>>m;\n\tint u, v;\n\tint count=0;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> u >> v;\n\t\tinsertSide(u, v);\n\t}\n\tdrawColor();\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (vertex[i] == black)\n\t\t{\n\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\tcount += findPath(i);\n\n\t\t}\n\t}\n\tcout << count << endl;\n\treturn 0;\n\n}\n\nvoid insertSide(int u, int v)\n{\n\tadjList[u].push_back(v);\n\tadjList[v].push_back(u);\n}\nvoid drawColor()\n{\n\tmemset(vertex, 0, sizeof(vertex));\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (vertex[i] == gray)\n\t\t{\n\t\t\tvertex[i] = black;\n\t\t\tqueue<int> q;\n\t\t\tq.push(i);\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tint index = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (vector<int>::iterator iter = adjList[index].begin(); iter != adjList[index].end(); ++iter)\n\t\t\t\t{\n\t\t\t\t\tif (vertex[*iter] == gray)\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(*iter);\n\t\t\t\t\t\tvertex[*iter] = 0 - vertex[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\nint findPath(int u)\n{\n\tfor (vector<int>::iterator iter = adjList[u].begin(); iter != adjList[u].end(); ++iter)\n\t{\n\t\tif (!visit[*iter])\n\t\t{\n\t\t\tvisit[*iter] = 1;\n\t\t\tif (findPath(match[*iter])||match[*iter] == 0)\n\t\t\t{\n\t\t\t\tmatch[u] = *iter;\n\t\t\t\tmatch[*iter] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n","source":"_posts/hihocoder-binarygraph.md","raw":"categories : hihocoder\ntitle: hihocoder算法练习之二分图\ntags : [hihocoder, algorithm, c++, 二分图, 二分图判定, 最大匹配]\ndate: 2015-10-11 19:31:05\n---\n\n# 二分图判定\n\n\n## 输入\n\n第1行：1个正整数T(1≤T≤10)\n接下来T组数据，每组数据按照以下格式给出：\n第1行：2个正整数N,M(1≤N≤10,000，1≤M≤40,000)\n第2..M+1行：每行两个整数u,v表示u和v之间有一条边\n\n\n## 输出\n\n\n第1..T行：第i行表示第i组数据是否有误。如果是正确的数据输出”Correct”，否则输出”Wrong”\n\n## 样例输入\n\n\n\t2\n\t5 5\n\t1 2\n\t1 3\n\t3 4\n\t5 2\n\t1 5\n\t5 5\n\t1 2\n\t1 3\n\t3 4\n\t5 2\n\t3 5\n\n\n## 样例输出\n\n\n\tWrong\n\tCorrect\n\n## 说明\n\n\n根据输入生成图，然后按照bfs或者dfs对顶点进行着，如果相邻的两个顶点为相同颜色，则判定不为二分图，注意数据中的非连通图。\n\n\n## 代码\n\n\n```\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<stack>\n#define M 40000\n#define N 10000\n#define gray 0\n#define black 1\n#define white -1\nint bfsGraph(int(&vertex)[N + 1], std::vector<int>(&vec)[N + 1], int k);\nint main()\n{\n\tint t;\n\tstd::cin >> t;\n\twhile (t--)\n\t{\n\t\tint n, m;\n\t\tint u, v;\n\t\tint flag = 1;\n\t\tstd::vector<int> vec[N + 1];\n\t\tint vertex[N + 1];\n\t\tstd::memset(vertex,0,sizeof(vertex));\n\t\tstd::cin >> n >> m;\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tstd::cin >> u >> v;\n\t\t\tvec[u].push_back(v);\n\t\t\tvec[v].push_back(u);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (vertex[i] == gray)\n\t\t\t{\n\t\t\t\tif (!bfsGraph(vertex, vec, i))\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t\tstd::cout << \"Correct\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"Wrong\" << std::endl;\n\t}\n\treturn 0;\n}\nint bfsGraph(int (&vertex)[N + 1], std::vector<int> (&vec)[N + 1],int k)\n{\n\tstd::stack<int> s;\n\tint index=k;\n\tvertex[index] = black;\n\ts.push(index);\n\twhile (!s.empty())\n\t{\n\t\tindex = s.top();\n\t\ts.pop();\n\t\tfor (std::vector<int>::iterator iter = vec[index].begin(); iter != vec[index].end(); ++iter)\n\t\t{\n\t\t\tif (vertex[*iter] == gray)\n\t\t\t{\n\t\t\t\tvertex[*iter] = 0 - vertex[index];\n\t\t\t\ts.push(*iter);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (vertex[*iter] + vertex[index] != 0)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n```\n\n# 二分图--最大匹配\n\n\n## 描述\n\n\n给定一个二分图G，在G的一个子图M中，M的边集中的任何两天边都不依附于同一个顶点，则称M是一个匹配，选择这样的子集中边数最大的子集称为图的最大匹配问题\n\n增光路(增广轨，交错轨)：P（增光轨）的顶点为未匹配点，属于M的边和不属于M的边在P上交错出现。\n\n匈牙利算法：找到增广路，并将增广路置反，每进行一次可以使M的匹配书加1\n\n如果所示：\n\n![](http://xiejun901.qiniudn.com/hihocoder二分图最大匹配.jpg)\n\n![](http://xiejun901.qiniudn.com/hihocoder二分图最大匹配2.jpg)\n\n如上图，在对点5进行判断时，发现点5‘已经于点4连接，此时我们需要递归对点4进行增广轨判断，如果点4的增光轨存在，我们需要将5-5’加入M，5’-4从M中去掉。递归会一直持续到判断点1，可以发现与点1相连的点1’未被匹配，因此结束递归。\n\n伪代码：\n\t\n\tfinpath(u)\n\t\tfor v connect u\n\t\t\tif(v未被访问过)\n\t\t\t\tv置访问\n\t\t\t\tif(v未被匹配 || findpath(v))\n\t\t\t\t\t将u-v加入M\n\t\t\t\t\treturn 1\n\t\treturn 0；\n\n\n\n## 完整代码\n\n\n```\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#define N 10+1\n#define M 10+1\n#define gray 0\n#define black 1\n#define white 0\nusing namespace std;\nint vertex[N] = { 0 };\nint match[N] = { 0 };\nint visit[N] = { 0 };\nvector<int> adjList[N];\nint n, m;\nvoid insertSide(int u, int v);\nvoid drawColor();\nint findPath(int u);\nint main()\n{\n\tcin >> n>>m;\n\tint u, v;\n\tint count=0;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> u >> v;\n\t\tinsertSide(u, v);\n\t}\n\tdrawColor();\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (vertex[i] == black)\n\t\t{\n\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\tcount += findPath(i);\n\n\t\t}\n\t}\n\tcout << count << endl;\n\treturn 0;\n\n}\n\nvoid insertSide(int u, int v)\n{\n\tadjList[u].push_back(v);\n\tadjList[v].push_back(u);\n}\nvoid drawColor()\n{\n\tmemset(vertex, 0, sizeof(vertex));\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (vertex[i] == gray)\n\t\t{\n\t\t\tvertex[i] = black;\n\t\t\tqueue<int> q;\n\t\t\tq.push(i);\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tint index = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (vector<int>::iterator iter = adjList[index].begin(); iter != adjList[index].end(); ++iter)\n\t\t\t\t{\n\t\t\t\t\tif (vertex[*iter] == gray)\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(*iter);\n\t\t\t\t\t\tvertex[*iter] = 0 - vertex[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\nint findPath(int u)\n{\n\tfor (vector<int>::iterator iter = adjList[u].begin(); iter != adjList[u].end(); ++iter)\n\t{\n\t\tif (!visit[*iter])\n\t\t{\n\t\t\tvisit[*iter] = 1;\n\t\t\tif (findPath(match[*iter])||match[*iter] == 0)\n\t\t\t{\n\t\t\t\tmatch[u] = *iter;\n\t\t\t\tmatch[*iter] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n","slug":"hihocoder-binarygraph","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwca003cd6jxqauggysr"},{"title":"C++中的返回值优化","date":"2015-10-20T13:11:01.000Z","_content":"\n之前面试的时候被问到过C++返回值优化的问题，然后发现自己没有理得很清楚，因此仔细去看一下理解一下并且写一篇博客记录一下\n记录的大部分内容应该会来源于[RVO V.S. std::move--Zhao Wu](https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en)以及[知乎网友的一些讨论](http://www.zhihu.com/question/29511959)\n\n## C/C++栈帧介绍\n先介绍一下x86-64中的16个64位寄存器\n\n![](http://7q5fny.com1.z0.glb.clouddn.com/blogx86-64寄存器2.png)\n图片来自[X86-64寄存器和栈帧](http://www.searchtb.com/2013/03/x86-64_register_and_function_frame.html)\n\n\t%rax: 作为函数返回值使用\n\t%rdi，%rsi，%rdx，%rcx，%r8，%r9: 用作函数参数，一次对应第一参数，第二参数\n\t%rsp: 堆栈指针，指向帧顶\n\t\n\t%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，\n\t简单说就是随便用，调用子函数之前要备份它，以防他被修改，rbp一般可以用来保存堆栈底指针\n\t%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值\n\n对于以下一段程序，用g++ 编译成汇编\n\t\n```C++\nint fun(int i)\n{\n\treturn i*2;\n}\nint main()\n{\n\tint i=10;\n    int j=fun(i);\n    return 0;\n}\n\n```\n\n```s\n\n\t.file\t\"test_stackfram.cpp\"\n\t.text\n\t.globl\t_Z3funi\n\t.type\t_Z3funi, @function\n_Z3funi:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t%edi, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\taddl\t%eax, %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\t_Z3funi, .-_Z3funi\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB1:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$16, %rsp\n\tmovl\t$10, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %edi\n\tcall\t_Z3funi\n\tmovl\t%eax, -8(%rbp)\n\tmovl\t$0, %eax\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE1:\n\t.size\tmain, .-main\n\t.ident\t\"GCC: (GNU) 5.2.0\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\n```\n\n从main函数看，首先进入main函数将%rbp入栈，然后将%rsp的值赋给%rbp，开始一个新的栈帧，此时帧顶栈底在同一个位置，表示了main函数的栈\n接下来会把局部i=10存在main函数的栈帧中，然后是通过寄存器%edi来传递参数调用fun函数，函数返回值会存在eax中，然后再将函数返回值置于main函数栈帧中的j局部变量，i位于(%rbp-4)的位置,位于j(%rbp-8)的位置\n\n看下fun函数，进入fun函数之后，会首先保存%rbp，即保存好调用方的栈帧的栈底指针，然后会将%rbp赋值为%rsp，开始一个新的栈帧，这个栈帧会用来存放fun函数的局部变量等等，如果再有一层调用，在被调用方会继续保存fun函数的堆栈底指针，并开辟新的栈帧\n\n\n\n","source":"_posts/cpp-rvo.md","raw":"title: C++中的返回值优化\ndate: 2015-10-20 21:11:01\ncategories: C++\ntags: [C++, RVO, 返回值优化, 函数调用, 栈帧]\n---\n\n之前面试的时候被问到过C++返回值优化的问题，然后发现自己没有理得很清楚，因此仔细去看一下理解一下并且写一篇博客记录一下\n记录的大部分内容应该会来源于[RVO V.S. std::move--Zhao Wu](https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en)以及[知乎网友的一些讨论](http://www.zhihu.com/question/29511959)\n\n## C/C++栈帧介绍\n先介绍一下x86-64中的16个64位寄存器\n\n![](http://7q5fny.com1.z0.glb.clouddn.com/blogx86-64寄存器2.png)\n图片来自[X86-64寄存器和栈帧](http://www.searchtb.com/2013/03/x86-64_register_and_function_frame.html)\n\n\t%rax: 作为函数返回值使用\n\t%rdi，%rsi，%rdx，%rcx，%r8，%r9: 用作函数参数，一次对应第一参数，第二参数\n\t%rsp: 堆栈指针，指向帧顶\n\t\n\t%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，\n\t简单说就是随便用，调用子函数之前要备份它，以防他被修改，rbp一般可以用来保存堆栈底指针\n\t%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值\n\n对于以下一段程序，用g++ 编译成汇编\n\t\n```C++\nint fun(int i)\n{\n\treturn i*2;\n}\nint main()\n{\n\tint i=10;\n    int j=fun(i);\n    return 0;\n}\n\n```\n\n```s\n\n\t.file\t\"test_stackfram.cpp\"\n\t.text\n\t.globl\t_Z3funi\n\t.type\t_Z3funi, @function\n_Z3funi:\n.LFB0:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t%edi, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\taddl\t%eax, %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE0:\n\t.size\t_Z3funi, .-_Z3funi\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB1:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$16, %rsp\n\tmovl\t$10, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %edi\n\tcall\t_Z3funi\n\tmovl\t%eax, -8(%rbp)\n\tmovl\t$0, %eax\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE1:\n\t.size\tmain, .-main\n\t.ident\t\"GCC: (GNU) 5.2.0\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\n```\n\n从main函数看，首先进入main函数将%rbp入栈，然后将%rsp的值赋给%rbp，开始一个新的栈帧，此时帧顶栈底在同一个位置，表示了main函数的栈\n接下来会把局部i=10存在main函数的栈帧中，然后是通过寄存器%edi来传递参数调用fun函数，函数返回值会存在eax中，然后再将函数返回值置于main函数栈帧中的j局部变量，i位于(%rbp-4)的位置,位于j(%rbp-8)的位置\n\n看下fun函数，进入fun函数之后，会首先保存%rbp，即保存好调用方的栈帧的栈底指针，然后会将%rbp赋值为%rsp，开始一个新的栈帧，这个栈帧会用来存放fun函数的局部变量等等，如果再有一层调用，在被调用方会继续保存fun函数的堆栈底指针，并开辟新的栈帧\n\n\n\n","slug":"cpp-rvo","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwch003nd6jxbgvz7h73"},{"title":"C++ 类型推导","date":"2015-10-12T14:07:06.000Z","_content":"\n本篇大概记录一下看Effective Modern C++这本书时对于类型推导这一部分内容。\n\n## 如何查看类型推导\n\n要了解类型推导首先应该是知道如何查看类型推导，下面简要介绍几种查看类型推导的方法\n\n### 编译期查看\n\n#### 通过IDE提供的信息查看\n\n以下是通过vs来查看auto的类型推断截图\n![](http://7q5fny.com1.z0.glb.clouddn.com/blogtype_deduced.jpg)\n\n#### 通过错误提示信息查看\n\n这方法也是罪了,如下代码\n```c++\ntemplate<typename T>\nclass D;\nint main()\n{\n    int x;\n    const auto &y = x;\n    D<decltype(x)> xType;\n    D<decltype(y)> yType;\n}\n```\n编译提示信息：\n\n    1>source2.cpp(7): error C2079: 'xType' uses undefined class 'D<int>'\n    1>source2.cpp(8): error C2079: 'yType' uses undefined class 'D<const int &>'\n    \n通过错误信息可以很清楚的看到 x 和 y 的类型\n\n### 运行期查看\n\n先介绍一个类 type_info，这个类是用来保存类的类型信息的，有一个成员name是来表示类型的名字的，可以通过typeid和type_info来在运行期获取类型的信息，\n不过由于type_info处理类型信息时是值传递的，所以显示信息会不太准，一些引用特性和常量特性会被消除，具体哪些会被消除可以根据后边会介绍的模板类型来知道。我们可以通过boost::typeindex来获得更准确类型信息\n\n## 模板的类型推导\n\n后边通过如下一段伪代码来举例, 我们需要得到ParamType 和 T\n\n```c++\ntemplate<typename T>\nvoid f(ParamType param);\n\nf(expr);\n```\n\nParamType 通过expr的类型推断而来，T的类型由ParamType 和 expr的类型共同得出\n具体可以分三种情况来看：\n1. ParamType 是指针或者引用但是不是universal reference(好吧，读到后面终于搞懂这个是个啥东西了。。对于type&& 是分两种情况的，一种是只能帮定位右值引用，另一种就随便了，因此被作者称为universal reference)\n2. ParamType 是universal reference\n3. ParamType 既不是指针也不是引用\n\n### ParamType 是指针或者引用但是不是universal reference\n\n对于这种情况，类型推导的原则是\n1. 如果expr是引用类型，忽视掉引用部分\n2. 然后通过expr的类型去匹配ParamType 来 得出T\n\n例如\n```c++\ntemplate<typename T>\nvoid f(T& param);\n\nint x=27;\nconst int cx=x;\nconst int& rx=x;\n\nf(x);   //T的类型是int,        param 的类型是 int&\nf(cx);  //T的类型是const int,  param 的类型是 const int&\nf(rx);  //T的类型是const int,  param 的类型是 const int&\n```\n\n改变一下ParamType 再看！\n\n```c++\ntemplate<typename T>\nvoid f(const T& param);\n\nint x=27;\nconst int cx=x;\nconst int& rx=x;\n\nf(x);   //T的类型是int,        param 的类型是 const int&\nf(cx);  //T的类型是int,        param 的类型是 const int&\nf(rx);  //T的类型是int,        param 的类型是 const int&\n```\n\n指针类型原则是一样的，就不再细说了\n\n### ParamType 是 universal reference\n\n对于这种情况，类型推导的原则是\n1. 如果expr是左值，那么ParamType和T都被推导为左值引用类型\n2. 如果expr是右值，那么按照之前的规则，根据expr匹配出ParamType，然后再推导出T\n\n需要注意的是，情况1有两个特殊的店，第一，它是唯一一种T被推导为引用类型的，第二，尽管ParamType被定义为&& 但是推导的类型为&, 下面举例说明\n\n```c++\ntemplate<typename T>\nvoid f(T&& param);\n\nint x=27;\nconst int cx=x;\nconst int& rx=x;\n\nf(x);   //T的类型是int&,              param 的类型是 int&\nf(cx);  //T的类型是const int&,        param 的类型是 const int&\nf(rx);  //T的类型是const int&,        param 的类型是 const int&\nf(27)   //T的类型是int                param 的类型是 int&&\n```\n\n### ParamType既不是引用也不是指针\n\n对于这种情况，类型推导的原则如下\n1. 如果expr是引用，那么忽略掉引用\n2. 如果是const, 那么忽略掉const。对于volatile也同样处理\n\n看下下面的例子\n\n```c++\ntemplate<typename T>\nvoid f(T param);\n\nint x=27;\nconst int cx=x;\nconst int& rx=x;\n\nf(x);   //T的类型是int,    param 的类型是 int\nf(cx);  //T的类型是int,    param 的类型是 int\nf(rx);  //T的类型是int,    param 的类型是 int\n```\n这里我们关注一下指向常量的常量指针的问题，\n例如我们有如下定义\n```c++\nconst char* p2k;       //(1)\nchar* const kp;        //(2)\nconst char* const kp2k //(3)\n```\n这三种情况是不一样的，\n情况1是指向常量的指针，表示的是指针指向的内容不可变，即我们无法执行*p2k = another这种操作\n情况2是常量指针，表示的是该指针变量是一个常量，即我们无法执行++kp这种操作\n情况3是以上两种情况结合， 指针不能变，指针指向的内容也不能变\n\n所以对于以下代码\n```c++\ntemplate<typename T>\nvoid f(T param);\n\nconst char* const ptr = \"hello\";\n\nf(ptr);   //T的类型是const char*,    param 的类型是 const char*\n```\n为什么呢，因为我们模板参数是按值传递的，所以ptr的常量特性被忽略掉了，然后得出了ParamType为const char\\* ， 从而推出T是 const char\\* ,\n这也很好理解，因为ptr指向的内容是不能改变的，那么即便通过函数传递进去了，内存的那部分内容还是应该是不能改变的，只是通过值传递的param是可以改变的了\n\n### 数组和函数的类型推导\n数组和函数在作为参数传递时，如果是按值传递，那么会自动退化为指针，如果是按引用传递，则不会退化为指针，根据这个原则，数组和函数的类型推导就很明白了\n举一个利用类型推导获取数组size的例子\n```c++\ntemplate<typename T, std::size_t N>\nconstexpr std::size_t arrySize(T (&)[N]) noexcept\n{\n    return N;\n}\n```\n\n## auto的类型推导 \n\nauto的类型推导在大部分情况下都和模板类型推导一模一样，除了当类型为initial_list的时候\n先介绍一下通常情况下的，与模板类型推导一样的那一部分\n```c++\nauto x = 27;           //x类型为int\nconst auto cx = x;     //cx类型为const int\nconst auto &rx = x;    //rx的类型为const int&\n\nauto&& uref1 = x;    //uref1的类型是 int&\nauto&& uref2 = cx;   //uref2的类型为 const int&\nauto&& uref3 = rx;   //uref3的类型为 const int&\nauto&& uref4 = 27;   //uref4的类型为 int&&\n\nconst char name[]=\"xiejun\";\n\nauto arr1 = name; //arr1的类型为 const char*;\nauto arr2 = name; //arr2的类型为 const char (&)[7]\n\nvoid Func(int, double);\nauto func1 = Func; //func1的类型为 void (*)(int, double)\nauto &func2 = Func; //func2的类型为 void (&)(int, double)\n\n```\n接下来看一下对于initial_list 的类型推导\n\n```c++\nauto x1 = {27};           //x类型为initial_list<int>\nauto x2 = {27, 3.0};  //报错\n\ntemplate<typename T>\nvoid f(T param);\n\nf({11, 23, 9}); //报错无法进行类型推导\n\ntemplate<typename T>\nvoid f(std::initial_list<T> param);\n\nf({11, 23, 9}); //ParamType 为initial_list<int> T为int\n\n```\n\n对于c++14, auto 可以用来定义函数返回值和lambda 表达式的参数，但是对于这两种情况，auto 将按照模板的类型推导来进行，对于initial_list将无法推导\n\n```c++\nauto createInitList()\n{\n    return {1, 2, 3, 4, 5}; //出错\n}\n\nauto resetV = [&v](const auto &newValue){v=newValue;}\nresetV({1, 2, 3}); //出错\n```\n\n## decltype的使用\ndecltype用来获取一个表达式的类型，举以下几个例子\n```c++\nint i=0;  //decltype(i) 是int\nconst int& cri=i;  //decltype(i) 是const int&\nbool f();  /decltype(f) 是bool\n```\n在C++11 中，decltype的主要作用是用来定义一个模板函数的返回值类型依赖于其输入类型，例如我们通常情况下vector<T> 的operator[]返回值为T&，\n但是对于vector<bool>，operator[]返回值为bool，不再是引用，我们想要我们写的函数的返回值与标准库中的operator[]表现一样，\n这时候便可以采用decltype来完成\n\n```c++\ntemplate<typename T>\nclass D;\n\ntemplate<typename Container, typename Index>\nauto authAndAccess(Container &c, Index i)\n->decltype(c[i])\n{\n    return c[i];\n}\nint main()\n{\n    vector<int> vec{ 1, 2, 3, 4 };\n    D<decltype(authAndAccess(vec, 2))> d;\n    \n    return 0;\n}\n```\n\n编译信息：\n1>error C2079: 'd' uses undefined class 'D<int &>'\n通过以上代码，我们通过错误信息可以得出函数的返回值是引用类型\n\n不过对于C++14，从语法层面上，可以不加decltype的\n```c++\ntemplate<typename T>\nclass D;\n\ntemplate<typename Container, typename Index>\nauto authAndAccess(Container &c, Index i)\n{\n    return c[i];\n}\nint main()\n{\n    vector<int> vec{ 1, 2, 3, 4 };\n    D<decltype(authAndAccess(vec, 2))> d;\n    \n    return 0;\n}\n```\n这种方式，如果采用c++11编译时会报出错误信息的\n\n    ‘authAndAccess’ function uses ‘auto’ type specifier without trailing return type\n\n对于c++14是能编译通过的(auto语法部分而不是整个示例代码)，但是正如我们前面提到的，返回值的引用类型或者常量类型是会被忽略的，因此对于以上示例代码，auto 推导出来的类型会是int而不是int&， 提示信息如下\n\n    error: aggregate ‘D<int> d1’ has incomplete type and cannot be defined D<decltype(authAndAccess(vec1, 2))> d1;\n    \n所以说对于 C++14 我们可以采用如下方式来写代码\n```c++\ntemplate<typename T>\nclass D;\n\ntemplate<typename Container, typename Index>\ndecltype(auto) authAndAccess(Container &c, Index i)\n{\n    return c[i];\n}\nint main()\n{\n    vector<int> vec{ 1, 2, 3, 4 };\n    D<decltype(authAndAccess(vec, 2))> d;\n    \n    return 0;\n}\n```\nauto 表明这个地方是要使用类型推断，decltype表明这个地方使用的是decltype的规则来进行类型推断，这样的话，推断出来的类型就是 int&了\n\n    error: aggregate ‘D<int&> d’ has incomplete type and cannot be defined D<decltype(authAndAccess(vec, 2))> d;\n\n\n不过这个写法还是有一定问题的，需要继续被完善。我们可以知道，以上代码参数传递是时无法传递右值的，因此我们最终的写法是\n```c++\n//C++14\ntemplate<typename Container, typename Index>\ndecltype(auto) authAndAccess(Container &&c, Index i)\n{\n    return std::forward<Container>(c)[i];\n}\n//C++11\ntemplate<typename Container, typename Index>\nauto authAndAccess(Container &&c, Index i)\n->decltype(std::forward<Container>(c)[i])\n{\n    return std::forward<Container>(c)[i];\n}\n```\n\n关于decltype还有一个很好玩的地方，对于 int x=0; decltype(x) 是int , 但是decltype((x)) 是int& 这个要注意一下\n也就是说会有如下情况\n```c++\ndecltype(auto) f1()\n{\n    int x=0;\n    ...\n    return x; //decltype(x) 是int, 函数f1的返回值是int类型\n}\n\ndecltype(auto) f1()\n{\n    int x=0;\n    ...\n    return (x); //decltype(x) 是int&, 函数f1的返回值是int&类型\n}\n```\n\n\n    \n","source":"_posts/DeducingType.md","raw":"title: C++ 类型推导\ndate: 2015-10-12 22:07:06\ntags: [C++, Effective Modern C++, C++类型推导, template, auto, decltype]\ncategories: Effective Modern C++\n---\n\n本篇大概记录一下看Effective Modern C++这本书时对于类型推导这一部分内容。\n\n## 如何查看类型推导\n\n要了解类型推导首先应该是知道如何查看类型推导，下面简要介绍几种查看类型推导的方法\n\n### 编译期查看\n\n#### 通过IDE提供的信息查看\n\n以下是通过vs来查看auto的类型推断截图\n![](http://7q5fny.com1.z0.glb.clouddn.com/blogtype_deduced.jpg)\n\n#### 通过错误提示信息查看\n\n这方法也是罪了,如下代码\n```c++\ntemplate<typename T>\nclass D;\nint main()\n{\n    int x;\n    const auto &y = x;\n    D<decltype(x)> xType;\n    D<decltype(y)> yType;\n}\n```\n编译提示信息：\n\n    1>source2.cpp(7): error C2079: 'xType' uses undefined class 'D<int>'\n    1>source2.cpp(8): error C2079: 'yType' uses undefined class 'D<const int &>'\n    \n通过错误信息可以很清楚的看到 x 和 y 的类型\n\n### 运行期查看\n\n先介绍一个类 type_info，这个类是用来保存类的类型信息的，有一个成员name是来表示类型的名字的，可以通过typeid和type_info来在运行期获取类型的信息，\n不过由于type_info处理类型信息时是值传递的，所以显示信息会不太准，一些引用特性和常量特性会被消除，具体哪些会被消除可以根据后边会介绍的模板类型来知道。我们可以通过boost::typeindex来获得更准确类型信息\n\n## 模板的类型推导\n\n后边通过如下一段伪代码来举例, 我们需要得到ParamType 和 T\n\n```c++\ntemplate<typename T>\nvoid f(ParamType param);\n\nf(expr);\n```\n\nParamType 通过expr的类型推断而来，T的类型由ParamType 和 expr的类型共同得出\n具体可以分三种情况来看：\n1. ParamType 是指针或者引用但是不是universal reference(好吧，读到后面终于搞懂这个是个啥东西了。。对于type&& 是分两种情况的，一种是只能帮定位右值引用，另一种就随便了，因此被作者称为universal reference)\n2. ParamType 是universal reference\n3. ParamType 既不是指针也不是引用\n\n### ParamType 是指针或者引用但是不是universal reference\n\n对于这种情况，类型推导的原则是\n1. 如果expr是引用类型，忽视掉引用部分\n2. 然后通过expr的类型去匹配ParamType 来 得出T\n\n例如\n```c++\ntemplate<typename T>\nvoid f(T& param);\n\nint x=27;\nconst int cx=x;\nconst int& rx=x;\n\nf(x);   //T的类型是int,        param 的类型是 int&\nf(cx);  //T的类型是const int,  param 的类型是 const int&\nf(rx);  //T的类型是const int,  param 的类型是 const int&\n```\n\n改变一下ParamType 再看！\n\n```c++\ntemplate<typename T>\nvoid f(const T& param);\n\nint x=27;\nconst int cx=x;\nconst int& rx=x;\n\nf(x);   //T的类型是int,        param 的类型是 const int&\nf(cx);  //T的类型是int,        param 的类型是 const int&\nf(rx);  //T的类型是int,        param 的类型是 const int&\n```\n\n指针类型原则是一样的，就不再细说了\n\n### ParamType 是 universal reference\n\n对于这种情况，类型推导的原则是\n1. 如果expr是左值，那么ParamType和T都被推导为左值引用类型\n2. 如果expr是右值，那么按照之前的规则，根据expr匹配出ParamType，然后再推导出T\n\n需要注意的是，情况1有两个特殊的店，第一，它是唯一一种T被推导为引用类型的，第二，尽管ParamType被定义为&& 但是推导的类型为&, 下面举例说明\n\n```c++\ntemplate<typename T>\nvoid f(T&& param);\n\nint x=27;\nconst int cx=x;\nconst int& rx=x;\n\nf(x);   //T的类型是int&,              param 的类型是 int&\nf(cx);  //T的类型是const int&,        param 的类型是 const int&\nf(rx);  //T的类型是const int&,        param 的类型是 const int&\nf(27)   //T的类型是int                param 的类型是 int&&\n```\n\n### ParamType既不是引用也不是指针\n\n对于这种情况，类型推导的原则如下\n1. 如果expr是引用，那么忽略掉引用\n2. 如果是const, 那么忽略掉const。对于volatile也同样处理\n\n看下下面的例子\n\n```c++\ntemplate<typename T>\nvoid f(T param);\n\nint x=27;\nconst int cx=x;\nconst int& rx=x;\n\nf(x);   //T的类型是int,    param 的类型是 int\nf(cx);  //T的类型是int,    param 的类型是 int\nf(rx);  //T的类型是int,    param 的类型是 int\n```\n这里我们关注一下指向常量的常量指针的问题，\n例如我们有如下定义\n```c++\nconst char* p2k;       //(1)\nchar* const kp;        //(2)\nconst char* const kp2k //(3)\n```\n这三种情况是不一样的，\n情况1是指向常量的指针，表示的是指针指向的内容不可变，即我们无法执行*p2k = another这种操作\n情况2是常量指针，表示的是该指针变量是一个常量，即我们无法执行++kp这种操作\n情况3是以上两种情况结合， 指针不能变，指针指向的内容也不能变\n\n所以对于以下代码\n```c++\ntemplate<typename T>\nvoid f(T param);\n\nconst char* const ptr = \"hello\";\n\nf(ptr);   //T的类型是const char*,    param 的类型是 const char*\n```\n为什么呢，因为我们模板参数是按值传递的，所以ptr的常量特性被忽略掉了，然后得出了ParamType为const char\\* ， 从而推出T是 const char\\* ,\n这也很好理解，因为ptr指向的内容是不能改变的，那么即便通过函数传递进去了，内存的那部分内容还是应该是不能改变的，只是通过值传递的param是可以改变的了\n\n### 数组和函数的类型推导\n数组和函数在作为参数传递时，如果是按值传递，那么会自动退化为指针，如果是按引用传递，则不会退化为指针，根据这个原则，数组和函数的类型推导就很明白了\n举一个利用类型推导获取数组size的例子\n```c++\ntemplate<typename T, std::size_t N>\nconstexpr std::size_t arrySize(T (&)[N]) noexcept\n{\n    return N;\n}\n```\n\n## auto的类型推导 \n\nauto的类型推导在大部分情况下都和模板类型推导一模一样，除了当类型为initial_list的时候\n先介绍一下通常情况下的，与模板类型推导一样的那一部分\n```c++\nauto x = 27;           //x类型为int\nconst auto cx = x;     //cx类型为const int\nconst auto &rx = x;    //rx的类型为const int&\n\nauto&& uref1 = x;    //uref1的类型是 int&\nauto&& uref2 = cx;   //uref2的类型为 const int&\nauto&& uref3 = rx;   //uref3的类型为 const int&\nauto&& uref4 = 27;   //uref4的类型为 int&&\n\nconst char name[]=\"xiejun\";\n\nauto arr1 = name; //arr1的类型为 const char*;\nauto arr2 = name; //arr2的类型为 const char (&)[7]\n\nvoid Func(int, double);\nauto func1 = Func; //func1的类型为 void (*)(int, double)\nauto &func2 = Func; //func2的类型为 void (&)(int, double)\n\n```\n接下来看一下对于initial_list 的类型推导\n\n```c++\nauto x1 = {27};           //x类型为initial_list<int>\nauto x2 = {27, 3.0};  //报错\n\ntemplate<typename T>\nvoid f(T param);\n\nf({11, 23, 9}); //报错无法进行类型推导\n\ntemplate<typename T>\nvoid f(std::initial_list<T> param);\n\nf({11, 23, 9}); //ParamType 为initial_list<int> T为int\n\n```\n\n对于c++14, auto 可以用来定义函数返回值和lambda 表达式的参数，但是对于这两种情况，auto 将按照模板的类型推导来进行，对于initial_list将无法推导\n\n```c++\nauto createInitList()\n{\n    return {1, 2, 3, 4, 5}; //出错\n}\n\nauto resetV = [&v](const auto &newValue){v=newValue;}\nresetV({1, 2, 3}); //出错\n```\n\n## decltype的使用\ndecltype用来获取一个表达式的类型，举以下几个例子\n```c++\nint i=0;  //decltype(i) 是int\nconst int& cri=i;  //decltype(i) 是const int&\nbool f();  /decltype(f) 是bool\n```\n在C++11 中，decltype的主要作用是用来定义一个模板函数的返回值类型依赖于其输入类型，例如我们通常情况下vector<T> 的operator[]返回值为T&，\n但是对于vector<bool>，operator[]返回值为bool，不再是引用，我们想要我们写的函数的返回值与标准库中的operator[]表现一样，\n这时候便可以采用decltype来完成\n\n```c++\ntemplate<typename T>\nclass D;\n\ntemplate<typename Container, typename Index>\nauto authAndAccess(Container &c, Index i)\n->decltype(c[i])\n{\n    return c[i];\n}\nint main()\n{\n    vector<int> vec{ 1, 2, 3, 4 };\n    D<decltype(authAndAccess(vec, 2))> d;\n    \n    return 0;\n}\n```\n\n编译信息：\n1>error C2079: 'd' uses undefined class 'D<int &>'\n通过以上代码，我们通过错误信息可以得出函数的返回值是引用类型\n\n不过对于C++14，从语法层面上，可以不加decltype的\n```c++\ntemplate<typename T>\nclass D;\n\ntemplate<typename Container, typename Index>\nauto authAndAccess(Container &c, Index i)\n{\n    return c[i];\n}\nint main()\n{\n    vector<int> vec{ 1, 2, 3, 4 };\n    D<decltype(authAndAccess(vec, 2))> d;\n    \n    return 0;\n}\n```\n这种方式，如果采用c++11编译时会报出错误信息的\n\n    ‘authAndAccess’ function uses ‘auto’ type specifier without trailing return type\n\n对于c++14是能编译通过的(auto语法部分而不是整个示例代码)，但是正如我们前面提到的，返回值的引用类型或者常量类型是会被忽略的，因此对于以上示例代码，auto 推导出来的类型会是int而不是int&， 提示信息如下\n\n    error: aggregate ‘D<int> d1’ has incomplete type and cannot be defined D<decltype(authAndAccess(vec1, 2))> d1;\n    \n所以说对于 C++14 我们可以采用如下方式来写代码\n```c++\ntemplate<typename T>\nclass D;\n\ntemplate<typename Container, typename Index>\ndecltype(auto) authAndAccess(Container &c, Index i)\n{\n    return c[i];\n}\nint main()\n{\n    vector<int> vec{ 1, 2, 3, 4 };\n    D<decltype(authAndAccess(vec, 2))> d;\n    \n    return 0;\n}\n```\nauto 表明这个地方是要使用类型推断，decltype表明这个地方使用的是decltype的规则来进行类型推断，这样的话，推断出来的类型就是 int&了\n\n    error: aggregate ‘D<int&> d’ has incomplete type and cannot be defined D<decltype(authAndAccess(vec, 2))> d;\n\n\n不过这个写法还是有一定问题的，需要继续被完善。我们可以知道，以上代码参数传递是时无法传递右值的，因此我们最终的写法是\n```c++\n//C++14\ntemplate<typename Container, typename Index>\ndecltype(auto) authAndAccess(Container &&c, Index i)\n{\n    return std::forward<Container>(c)[i];\n}\n//C++11\ntemplate<typename Container, typename Index>\nauto authAndAccess(Container &&c, Index i)\n->decltype(std::forward<Container>(c)[i])\n{\n    return std::forward<Container>(c)[i];\n}\n```\n\n关于decltype还有一个很好玩的地方，对于 int x=0; decltype(x) 是int , 但是decltype((x)) 是int& 这个要注意一下\n也就是说会有如下情况\n```c++\ndecltype(auto) f1()\n{\n    int x=0;\n    ...\n    return x; //decltype(x) 是int, 函数f1的返回值是int类型\n}\n\ndecltype(auto) f1()\n{\n    int x=0;\n    ...\n    return (x); //decltype(x) 是int&, 函数f1的返回值是int&类型\n}\n```\n\n\n    \n","slug":"DeducingType","published":1,"updated":"2016-02-28T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil87wwcm003zd6jxmv431s1j"}],"PostAsset":[],"PostCategory":[{"post_id":"cil87wwab0003d6jxl2bzo2tq","category_id":"cil87wwag0004d6jxkyp33c2a","_id":"cil87wwai0007d6jxwwzqdcbh"},{"post_id":"cil87wwam000ed6jx61ojmycy","category_id":"cil87wwao000fd6jxc9w49r2x","_id":"cil87wwao000id6jx5f586vkk"},{"post_id":"cil87wwas000rd6jx8bq5fz9d","category_id":"cil87wwag0004d6jxkyp33c2a","_id":"cil87wwat000sd6jxnsmfqmfo"},{"post_id":"cil87wway0013d6jx2xmn9a42","category_id":"cil87wwaz0014d6jxny6xge73","_id":"cil87wwaz0017d6jxsg0vvegl"},{"post_id":"cil87wwb3001gd6jxiubwat4h","category_id":"cil87wwb5001hd6jx68ujr4a4","_id":"cil87wwb5001kd6jxq94z2ijt"},{"post_id":"cil87wwby002kd6jxw411rrbz","category_id":"cil87wwbz002ld6jxlv8i37s5","_id":"cil87wwc0002od6jxqubprf4p"},{"post_id":"cil87wwc2002ud6jxa48wfa49","category_id":"cil87wwbz002ld6jxlv8i37s5","_id":"cil87wwc4002vd6jxbas489c5"},{"post_id":"cil87wwc70033d6jxjagae4mi","category_id":"cil87wwbz002ld6jxlv8i37s5","_id":"cil87wwc80034d6jxmdjhqd26"},{"post_id":"cil87wwca003cd6jxqauggysr","category_id":"cil87wwbz002ld6jxlv8i37s5","_id":"cil87wwcc003dd6jx0d6pjrv3"},{"post_id":"cil87wwch003nd6jxbgvz7h73","category_id":"cil87wwcj003od6jxasf248bh","_id":"cil87wwcj003rd6jxyqoffvyt"},{"post_id":"cil87wwcm003zd6jxmv431s1j","category_id":"cil87wwag0004d6jxkyp33c2a","_id":"cil87wwcn0040d6jx67a3iltn"}],"PostTag":[{"post_id":"cil87wwab0003d6jxl2bzo2tq","tag_id":"cil87wwag0005d6jxoxyf0e09","_id":"cil87wwak000ad6jx6cz6grzl"},{"post_id":"cil87wwab0003d6jxl2bzo2tq","tag_id":"cil87wwai0006d6jx92lehegp","_id":"cil87wwak000bd6jxff0vv1in"},{"post_id":"cil87wwab0003d6jxl2bzo2tq","tag_id":"cil87wwaj0008d6jxqa8w6o4k","_id":"cil87wwak000cd6jx0ap7qhcx"},{"post_id":"cil87wwab0003d6jxl2bzo2tq","tag_id":"cil87wwaj0009d6jxc18bsbjy","_id":"cil87wwak000dd6jxwijvwdu7"},{"post_id":"cil87wwam000ed6jx61ojmycy","tag_id":"cil87wwao000gd6jxixuunl71","_id":"cil87wwaq000md6jxh8rlbqh7"},{"post_id":"cil87wwam000ed6jx61ojmycy","tag_id":"cil87wwao000hd6jxxafsvnnp","_id":"cil87wwaq000nd6jxwqtzm1tz"},{"post_id":"cil87wwam000ed6jx61ojmycy","tag_id":"cil87wwap000jd6jxcx7t4u7u","_id":"cil87wwaq000od6jxo8q4gxld"},{"post_id":"cil87wwam000ed6jx61ojmycy","tag_id":"cil87wwap000kd6jxp9idps6q","_id":"cil87wwaq000pd6jx4iifj2iq"},{"post_id":"cil87wwam000ed6jx61ojmycy","tag_id":"cil87wwap000ld6jxszo3h05t","_id":"cil87wwaq000qd6jx9zuo10b9"},{"post_id":"cil87wwas000rd6jx8bq5fz9d","tag_id":"cil87wwai0006d6jx92lehegp","_id":"cil87wwaw000xd6jxqum08db4"},{"post_id":"cil87wwas000rd6jx8bq5fz9d","tag_id":"cil87wwaj0009d6jxc18bsbjy","_id":"cil87wwaw000yd6jxqo4o94vf"},{"post_id":"cil87wwas000rd6jx8bq5fz9d","tag_id":"cil87wwat000td6jxt94xqdcw","_id":"cil87wwaw000zd6jxb4w28ccy"},{"post_id":"cil87wwas000rd6jx8bq5fz9d","tag_id":"cil87wwav000ud6jxvhob65mh","_id":"cil87wwaw0010d6jx0yc0226p"},{"post_id":"cil87wwas000rd6jx8bq5fz9d","tag_id":"cil87wwav000vd6jxqs9qddce","_id":"cil87wwaw0011d6jxnzvrw1y1"},{"post_id":"cil87wwas000rd6jx8bq5fz9d","tag_id":"cil87wwaw000wd6jxwhx3iz50","_id":"cil87wwaw0012d6jxvl2cyov6"},{"post_id":"cil87wway0013d6jx2xmn9a42","tag_id":"cil87wwaz0015d6jxnzxp97w3","_id":"cil87wwb2001bd6jx0vfade2e"},{"post_id":"cil87wway0013d6jx2xmn9a42","tag_id":"cil87wwaz0016d6jx5oi4owma","_id":"cil87wwb2001cd6jxi8adshu9"},{"post_id":"cil87wway0013d6jx2xmn9a42","tag_id":"cil87wwb00018d6jx85vvq91c","_id":"cil87wwb2001dd6jx6yu0m2wk"},{"post_id":"cil87wway0013d6jx2xmn9a42","tag_id":"cil87wwb10019d6jxxeflfja2","_id":"cil87wwb2001ed6jxllh8co5c"},{"post_id":"cil87wway0013d6jx2xmn9a42","tag_id":"cil87wwb1001ad6jxdp4y2bbe","_id":"cil87wwb2001fd6jxulnuiciu"},{"post_id":"cil87wwb3001gd6jxiubwat4h","tag_id":"cil87wwb5001id6jxsb6jpt9r","_id":"cil87wwb7001md6jxya9r8yy3"},{"post_id":"cil87wwb3001gd6jxiubwat4h","tag_id":"cil87wwb5001jd6jxtd262mcu","_id":"cil87wwb7001nd6jxgizavx1m"},{"post_id":"cil87wwb3001gd6jxiubwat4h","tag_id":"cil87wwb6001ld6jxdomless2","_id":"cil87wwb7001od6jx93ues4pr"},{"post_id":"cil87wwb9001pd6jx9gggd292","tag_id":"cil87wwba001qd6jxwm2k4ftv","_id":"cil87wwbb001sd6jxpahfx3dy"},{"post_id":"cil87wwb9001pd6jx9gggd292","tag_id":"cil87wwba001rd6jxxuj6knk8","_id":"cil87wwbb001td6jxp8ffqlxb"},{"post_id":"cil87wwbe001ud6jxy3cj9in0","tag_id":"cil87wwbg001vd6jxhxb1cw4n","_id":"cil87wwbh001yd6jxw5zd9w2y"},{"post_id":"cil87wwbe001ud6jxy3cj9in0","tag_id":"cil87wwbh001wd6jxwpr0wvw7","_id":"cil87wwbh001zd6jxnxs2taty"},{"post_id":"cil87wwbe001ud6jxy3cj9in0","tag_id":"cil87wwbh001xd6jxkli96oab","_id":"cil87wwbh0020d6jxwe1vckz5"},{"post_id":"cil87wwbj0021d6jxj44aprmj","tag_id":"cil87wwbk0022d6jxiamikv1c","_id":"cil87wwbl0024d6jxh5u35epg"},{"post_id":"cil87wwbj0021d6jxj44aprmj","tag_id":"cil87wwba001rd6jxxuj6knk8","_id":"cil87wwbl0025d6jxszlotr96"},{"post_id":"cil87wwbj0021d6jxj44aprmj","tag_id":"cil87wwbl0023d6jxrnvtsndj","_id":"cil87wwbl0026d6jxd1xzlo7l"},{"post_id":"cil87wwbn0027d6jxcalfxc2z","tag_id":"cil87wwbo0028d6jxa6ihr4n1","_id":"cil87wwbp002ad6jxyafovcgs"},{"post_id":"cil87wwbn0027d6jxcalfxc2z","tag_id":"cil87wwba001rd6jxxuj6knk8","_id":"cil87wwbp002bd6jxwgmh9i1w"},{"post_id":"cil87wwbn0027d6jxcalfxc2z","tag_id":"cil87wwbo0029d6jxe5tk29u9","_id":"cil87wwbp002cd6jxjeb37skh"},{"post_id":"cil87wwbq002dd6jxjmvuf6th","tag_id":"cil87wwbr002ed6jx8pvvbwz4","_id":"cil87wwbs002gd6jx8p6q126m"},{"post_id":"cil87wwbq002dd6jxjmvuf6th","tag_id":"cil87wwbs002fd6jx4u1mz46s","_id":"cil87wwbs002hd6jxzkuk6vtr"},{"post_id":"cil87wwbu002id6jxq97y7uqs","tag_id":"cil87wwba001rd6jxxuj6knk8","_id":"cil87wwbv002jd6jxjq6ajkkn"},{"post_id":"cil87wwby002kd6jxw411rrbz","tag_id":"cil87wwbz002md6jx4iibpa50","_id":"cil87wwc1002qd6jxtsv9br3d"},{"post_id":"cil87wwby002kd6jxw411rrbz","tag_id":"cil87wwc0002nd6jxzfzkkufd","_id":"cil87wwc1002rd6jxpx9zcwfd"},{"post_id":"cil87wwby002kd6jxw411rrbz","tag_id":"cil87wwaz0016d6jx5oi4owma","_id":"cil87wwc1002sd6jxfjrvohn2"},{"post_id":"cil87wwby002kd6jxw411rrbz","tag_id":"cil87wwc0002pd6jxqov7ktlj","_id":"cil87wwc1002td6jxdms6tb5e"},{"post_id":"cil87wwc2002ud6jxa48wfa49","tag_id":"cil87wwbz002md6jx4iibpa50","_id":"cil87wwc5002yd6jx56fo5v5c"},{"post_id":"cil87wwc2002ud6jxa48wfa49","tag_id":"cil87wwc0002nd6jxzfzkkufd","_id":"cil87wwc5002zd6jxexwxgemp"},{"post_id":"cil87wwc2002ud6jxa48wfa49","tag_id":"cil87wwaz0016d6jx5oi4owma","_id":"cil87wwc50030d6jxb9ak3cpi"},{"post_id":"cil87wwc2002ud6jxa48wfa49","tag_id":"cil87wwc4002wd6jxsak8sd6y","_id":"cil87wwc50031d6jxzd9lnhv4"},{"post_id":"cil87wwc2002ud6jxa48wfa49","tag_id":"cil87wwc5002xd6jxl1dq515j","_id":"cil87wwc50032d6jx7jj782sr"},{"post_id":"cil87wwc70033d6jxjagae4mi","tag_id":"cil87wwbz002md6jx4iibpa50","_id":"cil87wwc90037d6jxpnart58j"},{"post_id":"cil87wwc70033d6jxjagae4mi","tag_id":"cil87wwc0002nd6jxzfzkkufd","_id":"cil87wwc90038d6jxykgvobu1"},{"post_id":"cil87wwc70033d6jxjagae4mi","tag_id":"cil87wwaz0016d6jx5oi4owma","_id":"cil87wwc90039d6jxmdfq4zbo"},{"post_id":"cil87wwc70033d6jxjagae4mi","tag_id":"cil87wwc80035d6jxkhy60l1t","_id":"cil87wwc9003ad6jxx569mykd"},{"post_id":"cil87wwc70033d6jxjagae4mi","tag_id":"cil87wwc80036d6jxorlozyw3","_id":"cil87wwc9003bd6jxjqfxl6du"},{"post_id":"cil87wwca003cd6jxqauggysr","tag_id":"cil87wwbz002md6jx4iibpa50","_id":"cil87wwcd003hd6jxqhixkpe6"},{"post_id":"cil87wwca003cd6jxqauggysr","tag_id":"cil87wwc0002nd6jxzfzkkufd","_id":"cil87wwce003id6jxapcwnj9e"},{"post_id":"cil87wwca003cd6jxqauggysr","tag_id":"cil87wwaz0016d6jx5oi4owma","_id":"cil87wwce003jd6jxobjz4c1n"},{"post_id":"cil87wwca003cd6jxqauggysr","tag_id":"cil87wwcc003ed6jx46azg489","_id":"cil87wwce003kd6jx1ee5zli8"},{"post_id":"cil87wwca003cd6jxqauggysr","tag_id":"cil87wwcd003fd6jxuhi8ww47","_id":"cil87wwce003ld6jxo9bwfekz"},{"post_id":"cil87wwca003cd6jxqauggysr","tag_id":"cil87wwcd003gd6jx2baxla2x","_id":"cil87wwce003md6jxzts94dkl"},{"post_id":"cil87wwch003nd6jxbgvz7h73","tag_id":"cil87wwai0006d6jx92lehegp","_id":"cil87wwck003ud6jxtkxbwwgk"},{"post_id":"cil87wwch003nd6jxbgvz7h73","tag_id":"cil87wwcj003pd6jxygzo1c5o","_id":"cil87wwck003vd6jx08aqxxop"},{"post_id":"cil87wwch003nd6jxbgvz7h73","tag_id":"cil87wwcj003qd6jxx9v5tvzu","_id":"cil87wwck003wd6jxdwi2zyoz"},{"post_id":"cil87wwch003nd6jxbgvz7h73","tag_id":"cil87wwck003sd6jx8cz6jk2q","_id":"cil87wwck003xd6jxu8n8km0i"},{"post_id":"cil87wwch003nd6jxbgvz7h73","tag_id":"cil87wwck003td6jxllraqxhj","_id":"cil87wwck003yd6jxnb93ha8y"},{"post_id":"cil87wwcm003zd6jxmv431s1j","tag_id":"cil87wwai0006d6jx92lehegp","_id":"cil87wwcn0041d6jxg8y1t1cw"},{"post_id":"cil87wwcm003zd6jxmv431s1j","tag_id":"cil87wwaj0009d6jxc18bsbjy","_id":"cil87wwcn0042d6jxa7gdb9m2"},{"post_id":"cil87wwcm003zd6jxmv431s1j","tag_id":"cil87wwat000td6jxt94xqdcw","_id":"cil87wwco0043d6jxi85hh3ax"},{"post_id":"cil87wwcm003zd6jxmv431s1j","tag_id":"cil87wwav000ud6jxvhob65mh","_id":"cil87wwco0044d6jxsqlt1vp2"},{"post_id":"cil87wwcm003zd6jxmv431s1j","tag_id":"cil87wwav000vd6jxqs9qddce","_id":"cil87wwco0045d6jx5cqqvgzq"},{"post_id":"cil87wwcm003zd6jxmv431s1j","tag_id":"cil87wwaw000wd6jxwhx3iz50","_id":"cil87wwco0046d6jx3ykeg568"}],"Tag":[{"name":"reference","_id":"cil87wwag0005d6jxoxyf0e09"},{"name":"C++","_id":"cil87wwai0006d6jx92lehegp"},{"name":"universal reference","_id":"cil87wwaj0008d6jxqa8w6o4k"},{"name":"Effective Modern C++","_id":"cil87wwaj0009d6jxc18bsbjy"},{"name":"TCP","_id":"cil87wwao000gd6jxixuunl71"},{"name":"socket","_id":"cil87wwao000hd6jxxafsvnnp"},{"name":"Linux","_id":"cil87wwap000jd6jxcx7t4u7u"},{"name":"FIN","_id":"cil87wwap000kd6jxp9idps6q"},{"name":"RST","_id":"cil87wwap000ld6jxszo3h05t"},{"name":"C++类型推导","_id":"cil87wwat000td6jxt94xqdcw"},{"name":"template","_id":"cil87wwav000ud6jxvhob65mh"},{"name":"auto","_id":"cil87wwav000vd6jxqs9qddce"},{"name":"decltype","_id":"cil87wwaw000wd6jxwhx3iz50"},{"name":"singleton","_id":"cil87wwaz0015d6jxnzxp97w3"},{"name":"c++","_id":"cil87wwaz0016d6jx5oi4owma"},{"name":"design pattern","_id":"cil87wwb00018d6jx85vvq91c"},{"name":"设计模式","_id":"cil87wwb10019d6jxxeflfja2"},{"name":"单例模式","_id":"cil87wwb1001ad6jxdp4y2bbe"},{"name":"operating system","_id":"cil87wwb5001id6jxsb6jpt9r"},{"name":"file system","_id":"cil87wwb5001jd6jxtd262mcu"},{"name":"modern operating systems","_id":"cil87wwb6001ld6jxdomless2"},{"name":"string","_id":"cil87wwba001qd6jxwm2k4ftv"},{"name":"java","_id":"cil87wwba001rd6jxxuj6knk8"},{"name":"多态","_id":"cil87wwbg001vd6jxhxb1cw4n"},{"name":"抽象类","_id":"cil87wwbh001wd6jxwpr0wvw7"},{"name":"接口","_id":"cil87wwbh001xd6jxkli96oab"},{"name":"generic","_id":"cil87wwbk0022d6jxiamikv1c"},{"name":"object","_id":"cil87wwbl0023d6jxrnvtsndj"},{"name":"file","_id":"cil87wwbo0028d6jxa6ihr4n1"},{"name":"io","_id":"cil87wwbo0029d6jxe5tk29u9"},{"name":"异常","_id":"cil87wwbr002ed6jx8pvvbwz4"},{"name":"exception","_id":"cil87wwbs002fd6jx4u1mz46s"},{"name":"hihocoder","_id":"cil87wwbz002md6jx4iibpa50"},{"name":"algorithm","_id":"cil87wwc0002nd6jxzfzkkufd"},{"name":"trie图","_id":"cil87wwc0002pd6jxqov7ktlj"},{"name":"trie树","_id":"cil87wwc4002wd6jxsak8sd6y"},{"name":"字典树","_id":"cil87wwc5002xd6jxl1dq515j"},{"name":"kmp","_id":"cil87wwc80035d6jxkhy60l1t"},{"name":"next数组","_id":"cil87wwc80036d6jxorlozyw3"},{"name":"二分图","_id":"cil87wwcc003ed6jx46azg489"},{"name":"二分图判定","_id":"cil87wwcd003fd6jxuhi8ww47"},{"name":"最大匹配","_id":"cil87wwcd003gd6jx2baxla2x"},{"name":"RVO","_id":"cil87wwcj003pd6jxygzo1c5o"},{"name":"返回值优化","_id":"cil87wwcj003qd6jxx9v5tvzu"},{"name":"函数调用","_id":"cil87wwck003sd6jx8cz6jk2q"},{"name":"栈帧","_id":"cil87wwck003td6jxllraqxhj"}]}}